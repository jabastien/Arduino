
// Written by Dennis Frie - 2011
// Contact: Dennis.frie@gmail.com

// Notes on DIY hardware pins:;
// pin 6 = PD6 / AIN0 (Reference voltage)
// Pin 7 = PD7 / AIN1 (Video)
// Pin 11 = MOSI (SPI) used for pixel-generation. 
// Pin 8 = Dimming (Optional)
// Pin 9 = Fast PWM (Optional)

// NMEA GPGGA and GPRMC should be used

#include <avr/delay.h>
#include <avr/pgmspace.h>
#include <EEPROM.h>

//===========================
// Hardware Arduino or SimpleOSD 16 mhz??
//===========================

// from code version 5, support for 16 mhz SimpleOSD with Arduino bootloader have been added. It uses the 
//same microcontroller etc - but a LM1881 chip is used to detect new lines and frames.

//Arduino = 0, SimpleOSD = 1
#define controller 0

//===========================
// Video system: PAL or NTSC
//===========================
// Pal = 0, NTSC = 1
#define video_system 0


//=============================================================================================
// Setup
//=============================================================================================

// Baud-rate for GPS
#define baud 9600

// Current-sensor
#define offset 0
#define current_cal 0.24 
// These values should more or less be correct. Feel free to make a calibration (a few measurements and a linear approksimation) if you feel like it. 
// 25 A sensor = 0.24
// 50 A sensor = 0.49
// 100A sensor = 0.98

// How to calculate it...
// Let's say we use a 25 A current sensor that outputs 1 volt for every 5 amps.
// Our microcontroller will have 0 v = 0 and 5 volt = 1024. This means 5 A (1 volt) will show as 1024 / 5 = 205
// We want to show the amps as xx.x A - but we don't want decimals, so we will keep it a factor 10 higher.
// The calibration should then be 205 * x = 50 A (in theory 5 A, but remember the factor 10). This gives 50/205 = 0.24
// You can also take measurements and make a linear approksimatioin in excel etc - a quick test gave me more or less the same result...

// Voltage divider
#define voltage_divider_cal 1.82          // For SimpleOSD, I have used 1.82 - the formula gives 1.86. Test with a multimeter 
// Calculated by (1024)/(50*divider) 

//Altitude offset (automatic set to 0 when home-position is set)
//1 = on, 0=off.
#define altitude_offset_on_ 0

// Delay when setting home position. When GPS have GPS-fix the homeposition will automatically be set. For better accuracy a delay can be added. The delay is defined as GPS update-rate / value set.
// Example: 5 hz GPS with 25 delay will give 5 hz / 25 delay = 5 seconds delay.
#define set_home_delay 25

// Align text. On different screens/video signals I have seen, that the text is not alligned perfectly. Decreasing the number will move all text left, increasing the number will move it right.
// Smallest number allowed is 1
// Please be aware - no limits have been made, so you can move the entire text as much as you want. If you push the text "over the edge" (when you can't see it anymore) this will cause the text 
// to interrupt with the "new line sync". You can give it a try to see what it does - but I deffinately recommend to keep the text on the screen when flying :) 
#define align_text_ 22


// Depending on your model (plane/heli/car) it can be necessary to edit these parameters to show flight-summary only when landed. To disable it, just put for example 0 in speed. The speed will never be less than 0.  

// As default configured for standard plane
///*
#define summary_speed 5       // Speed less than (in km/h)
#define summary_los 100       // LOS less than (in meters)
#define summary_current 99   // Current less than (in amps)
#define summary_time 0       // Flight time more than (in seconds)
#define summary_altitude 999  // altitude less than (in meters)
//*/

/* 
// Quad/helicopter example
#define summary_speed 99       // Speed less than (in km/h)
#define summary_los 9999       // LOS less than (in meters)
#define summary_current 3   // Current less than (in amps)
#define summary_time 0       // Flight time more than (in seconds)
#define summary_altitude 999  // altitude less than (in meters)
*/

// I was asked to make a calculation on mah/km - this can be useful to find the most efficient cruise-speed etc.
// It can be turned on and off as you want. Please note that it will only update when the speed is > 1 km/h.
// The number will show above mah and without unit (it's mah/km). 
//1 = on, 0=off.
#define show_mah_km_ 1

// For a cleaner look it's possible to remove decimals from speed and altitude. Speeds < 10 km/h will still show with decimals (can be changed if you wan't). 
//1 = on, 0=off.
#define show_decimals_ 1

// Hide GPS-coordinates when altitude is more than x meter
#define show_gps_coordinates_altitude 200


// If GPS-coordinates are hidden when flying higher than x m, GPS-coordinates can show every x second. If anyone uses this it should be updated a bit, right now it only looks at the last number
// Value should be 1-9 (1 = show every second (always), 2 = show once every 2. second etc.)
#define show_gps_coordinates_second 9


// Dimming can be turned off. Mainly for debugging
// 1 = on, 0 = off
#define dim_on 1

// Show plane pos
#define show_plane_pos_ 1

// Units. Meters and km/hr, or feet and miles
// 1 = meters, 0 = feet
#define units 1

// Used stored values
// From version 15 settings can be saved. This means, that even when updating software or reloading firmware settings will remain
// If you want to load the settings from this code, please change this value to 1, upload the code, change the value to 0 and upload again.
// 1 = reset/reload values, 0 = don't reload values. 
#define reset_values 0

// From software version 15 a menu can be used for configuration. You only need a single button. If no button is used, menu should be turned off.
// It will always be on if controller 1 (SimpleOSD OPEN have been choosen)
// 1 = on, 0 = off:
#define Usebutton 1

// The arduino-pin Button-pin is connected to:
#define Buttonpin_ 2

//======================================================
// Set alarms. Will blink when value is exceeded
//======================================================
// Voltage alarm (voltage will blink if it drops below the given value). To avoid decimal, use a factor 10 higher value, meaning 10 volt = 100, 8 Volt = 80 etc. 
#define volt_alarm_ 100 // 100 = 10 volt

// mah alarm. mah will blink if it exceeds the defined value. Should be written in mah, meaning 2000 mah = 2000. 
#define mah_alarm_ 2000

// los alarm. los-number will blink if it exceeds the defined value. Should be written in meter, meaning 2000 meter = 2000, 4 km = 4000 etc. 
#define los_alarm_ 2000

// Altitude alarm. altitude-number will blink if it exceeds the defined value. Should be written in meter, meaning 2000 meter = 2000, 4 km = 4000 etc. 
#define alt_alarm_ 1100



//========================================================================
// END SETUP
//========================================================================


#if (video_system == 0)
  // PAL
  #define toplinetext 41
  #define toplinenumbers 51
  #define butlinenumbers 271
  #define timer_line 252
  #define gps_nmea_line 32
  #define summaryline 102
  #define current_calc_line 292
#else 
  //NTSC
  #define toplinetext 24
  #define toplinenumbers 34
  #define butlinenumbers 229
  #define timer_line 210
  #define gps_nmea_line 15
  #define summaryline 100
  #define current_calc_line 260
#endif

// Arduino
#if (controller == 0)

// Input from current-sensor and voltage-divider
  #define voltage_divider_input 1
  #define current_sensor_input 1


#if (dim_on == 1)
// This is used for dimming. can be changed to another pin if you want. 
  #define DimOn  DDRB |= 0b00000001;
  #define DimOff DDRB &= 0b11111110;
#else
  #define DimOn  DDRB |= 0b00000000;
  #define DimOff DDRB &= 0b11111111;
#endif  
  
  #define little_delay
  
  
 // SimpleOSD XL 16 mhz
#else
         
  // Input from current-sensor and voltage-divider
  #define voltage_divider_input 7
  #define current_sensor_input 4
  
#if (dim_on == 1)
// This is used for dimming. can be changed to another pin if you want. 
 //define SimpleOSD OPEN's dim pin C5
  #define DimOn  DDRC |= 0b00100000;
  #define DimOff DDRC &= 0b11011111;
#else
  #define DimOn  DDRB |= 0b00000000;
  #define DimOff DDRB &= 0b11111111;
#endif    
  

  
  #define little_delay _delay_loop_1(13);
  
#endif

#define mux_currentSens ADMUX = (0<<MUX3) | (0<<MUX2) | (0<<MUX1) | (current_sensor_input<<MUX0) | (1<<REFS0) |(0<<REFS1);
#define mux_batVoltage ADMUX = (0<<MUX3) | (0<<MUX2) | (0<<MUX1) | (voltage_divider_input<<MUX0) | (1<<REFS0) |(0<<REFS1);

// Lets define some delays
#define delay15 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay14 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay13 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay12 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay11 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay10 __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay9  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay8  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay7  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay6  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay5  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay4  __asm__("nop\n\t""nop\n\t""nop\n\t""nop\n\t"); 
#define delay3  __asm__("nop\n\t""nop\n\t""nop\n\t"); 
#define delay2  __asm__("nop\n\t""nop\n\t"); 
#define delay1  __asm__("nop\n\t"); 

#define clock 16000000
#define baud_settings clock/16/baud-1

// Linenumber
int line =0;


void setup() {
pinMode(10,OUTPUT);
pinMode(11,OUTPUT);  
pinMode(12,OUTPUT);
pinMode(13,OUTPUT);

pinMode(0,INPUT);  
pinMode(1,INPUT);
pinMode(2,INPUT);
pinMode(3,INPUT);
pinMode(4,INPUT);  
pinMode(5,INPUT);
pinMode(6,INPUT); 
pinMode(7,INPUT);
pinMode(8,INPUT);  
pinMode(9,INPUT);


// Init Serial communication. 
Serial.begin(baud);
 UBRR0H = (unsigned char) (baud_settings>>8);
 UBRR0L = (unsigned char) (baud_settings);
 UCSR0A = 0b0000000;
 UCSR0B = (1<<RXEN0) | (1<<TXEN0);
 UCSR0C = (3<<UCSZ00);

// Used to set the GPS update-rate to 5 hz, and only 2 gps-strings (Only for MKT-GPS).

  Serial.print("$PMTK300,200,0,0,0,0*2F");
  Serial.print(13,BYTE);
  Serial.print(10,BYTE); 

  Serial.print("$PMTK314,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28");
  Serial.print(13,BYTE);
  Serial.print(10,BYTE);

 
// Enable SPI for pixel generation
// Set SPI;  
  SPCR = 
  (1<<SPE) | //Enable SPI
  (1<<MSTR)| // Set as master
  (0<<SPR1)| // Max speed
  (0<<SPR0)| // Max speed
  (0<<DORD)| // Year, Try to set this to 1 :D (Will mirror the byte)
  (1<<CPOL)| // Doesnt really matter, its the SCK polarity
  (1<<CPHA); //
  
  SPSR = (1<<SPI2X); // SPI double speed - we want 8 mhz output speed.
  SPDR =0b00000000; // IMPORTANT.. The SPI will idle random at low or high in the beginning. If it idles high you will get black screen = bad idea in FPV.
  // It will always idle at the last bit sent, so always be sure the last bit is 0. The main-loop and end of each line will always send 8 times zero - so it should
  // be pretty safe. 
  
// Analog read enable and set prescale. You can change prescale if you like.
  ADCSRA = (1<<ADEN) | (1<<ADPS2) | (0<<ADPS1) | (1<<ADPS0);
  
// Disable standard Arduino interrupts used for timer etc. (you can clearly see the text flicker if they are not disabled)
  TIMSK0=0;
  TIMSK1=0;
  TIMSK2=0;
  
// If Arduino is used
if (controller == 0) {
// Init analog comparator to register new line and frame
  ADCSRB = 0b00000001; // Set analog comparator mode
  
  ACSR = 0b00001011; //Enable Analog comparator interrupt 

// Set interrupt on falling output edge.  
  ADCSRA|=(1<<ADSC);    
  
// Start timer 2 - used to determine if it's a new frame or line. 
  TCCR2B =
  (0<<CS22) | //Prescale 1024
  (0<<CS21) | //Prescale 1024
  (1<<CS20) | //Prescale 1024
  (0<<WGM22); // CTC mode (Clear timer on compare match)  

// Button with internal pull-up.  
  pinMode(Buttonpin_,INPUT);
  digitalWrite(Buttonpin_,HIGH);
}

// If SimpleOSD/LM1881
if (controller == 1) {
  attachInterrupt(0,detectline,FALLING);
  attachInterrupt(1,detectframe,RISING);  
  pinMode(5,OUTPUT);
  digitalWrite(5,HIGH); // Turn on the led

// Button with internal pull-up.
  pinMode(6,INPUT);
  digitalWrite(6,HIGH);

}





// If the controller have not been configured yet. 
if ((EEPROM.read(0) != 52) | (reset_values == 1)) {
  EEPROM.write(0,52);
  
  // Show_mah_km
  EEPROM.write(1,show_mah_km_);
  
  // Show decimals
  EEPROM.write(2,show_decimals_);
  
  // Altitude offset
  EEPROM.write(3,altitude_offset_on_);
  
  // Align text
  EEPROM.write(4,align_text_);
  
  // Show plane pos
  EEPROM.write(5,show_plane_pos_);  
  
  // Alt alarm
  EEPROM.write(10,(unsigned char) alt_alarm_);
  EEPROM.write(11,(unsigned char) (alt_alarm_>>8));  
  
  EEPROM.write(12,(unsigned char) los_alarm_);
  EEPROM.write(13,(unsigned char) (los_alarm_>>8));  

  EEPROM.write(14,(unsigned char) volt_alarm_);
  EEPROM.write(15,(unsigned char) (volt_alarm_>>8));  

  EEPROM.write(16,(unsigned char) mah_alarm_);
  EEPROM.write(17,(unsigned char) (mah_alarm_>>8));    
}





}


unsigned char toptext[12] = {'S'-64,'P'-64,'E'-64,'E'-64,'D'-64,'L'-64,'O'-64,'S'-64,'A'-64,'L'-64,'T'-64,20};
int temp =0;

// Standard integers to use with for/while loops etc.
int a=0;
int i=0;
int k=0;

unsigned char ii=0;


//========================================
// Data read from GPS
//========================================
 unsigned char time[14]={1,1,1,1,1,1,1,1,1,1,1,1};;
 unsigned char speedkn[10]={1,1,1,1,1};
 unsigned char speedkn2[10]={1,1,1,1,1};
 unsigned char speedkmw[5]={1,1,1,1,1};
 unsigned int speedkm =0;
 unsigned int speedkm2 =0;
 int latitude[15]={0};
 int longitude[15]={0};
 int head[10]={0};
 unsigned char altitude[10]={1,1,1,1,1,1};
 unsigned char altitude2[10]={1,1,1,1,1,1}; 
 unsigned char altituder[10]={1,1,1,1,1,1,1,1};
 unsigned char altituder2[10]={1,1,1,1,1,1,1,1};
 long altitude_offset =0;
 int altitude_negative=0;

 // Buffer for GPS string
 char GPSbuffer[100]={0};


//========================================
// Data for mAh
//========================================
// Measuring amps and mah's;
int loopcount=0;
int current=0;
int current_num=0;
unsigned char currentr[] = {3,3,3,3,3}; // Stores current characters (numbers) written to screen
unsigned char voltager[] = {3,3,3,3,3}; // Stores current characters (numbers) written to screen
int bat_volt =0;

long mah = 0;
long mahtemp=0;
unsigned char mahr[]={3,3,3,3,3,3}; // Stores mah characters (numbers) written to screen
unsigned char losr[]={1,1,1,1};     // Stores LOS characters (numbers) written to screen
unsigned char arrowr[] ={3,3,3};

//ADC (It's a 10 bit ADC, so we need to read from 2 registers and put them together. This is what ADSCtemp is used for
 int ADCtemp=0;
 int ADCtemp2=0;
 int ADCreal=0;  // Just a stupid name for the complete analog-read
 int ADCreal2=0; // Can be replaced with ADCreal



//========================================
// Buffers
//========================================
unsigned char buffer[20];

// Need an integer when reading large characeters (will exceed 256)
int buffer2[12]={12,12,12,12,12,12,12,12,12,12,12,12};
unsigned int buffer3[15];


//==================================
// Decleration for GPS-variables
//==================================

// Has homeposition been set?
char homepos=0;
// Simple way to make a little delay before the homeposition is set. (It waits for GPS-fix, waits a couple of ekstra seconds and set homeposition)
int homeposcount=0;

// GPSfix - when '0' no satellite fix.
char GPSfix='0';

// Used to store all the GPS positions etc...
long lat1=0;
long lat2=0;
long lats=0;

long lon1=0;
long lon2=0;
long lons=0;

long losy=0;
long losx=0;

// Variables to store home position:
long lathome = 0;
long lonhome = 0;
long los = 0;

int homehead=0;
int homehead_r[3]={96,96,96};
int headi=0;
int arrow=0;
int arrowd;
unsigned char satellites[3]={3,3,3};
unsigned char satellitesr[3]={3,3,3};

unsigned char latitude_dir =0;
unsigned char longitude_dir =0;

float longitude_factor =1;
int lat_deg = 90;
//========================================
// Variables when analyzing serial data (GPS)
//========================================

// For GPS/Serial read
// bufnr counts the number of characters received. N used to when extracting 
// data from GPS strings.
 int bufnr=0; // Bytes are stored in an array. bufnr "counts the characters" 
 int n=0;
 int count =0;
 
//========================================
// For flight summary
//========================================
long max_los =0;
unsigned char max_losr[] = {3,3,3,3};

int max_speed =0;
unsigned char max_speedr[] = {3,3,3,3};

long kmh_total =0;
unsigned char total_distancer[] = {3,3,3,3,3};

long max_alt=0;
unsigned char max_altr[] = {3,3,3,3,3,3};

unsigned char landed =1;
long altitude_num=0;
long altitude_num2=0;
int altitude_int=0;

unsigned long flight_time =0;
unsigned char last_time=0;
unsigned char flight_timer[] = {3,3,3,3,3,3};

int avg_speed =0;
unsigned char avg_speedr[] = {3,3,3,3,3,3};

unsigned char loadbar[]={29,27,27,27,27,27,27,27,27,28};

unsigned char test=0;


//========================================
// Menu system
//========================================

/*
int menuon = 0;
unsigned char menupos = 0;
unsigned char move_arrow_count =0;

unsigned char show_mah_km = show_mah_km_;
unsigned char show_decimals = show_decimals_;
unsigned char altitude_offset_on = altitude_offset_on_;
unsigned char align_text = align_text_;
unsigned char show_plane_pos = show_plane_pos_;
*/

unsigned char Buttonpin = Buttonpin_;

int menuon = 0;
unsigned char menupos = 0;
char move_arrow_count =0;
unsigned char menu = 1;
  
unsigned char show_mah_km = EEPROM.read(1);
unsigned char show_decimals = EEPROM.read(2);
unsigned char altitude_offset_on = EEPROM.read(3);
unsigned char align_text = EEPROM.read(4);
unsigned char show_plane_pos = EEPROM.read(5);

int alt_alarm = EEPROM.read(10)+(EEPROM.read(11)<<8);
int los_alarm = EEPROM.read(12)+(EEPROM.read(13)<<8);
int volt_alarm =EEPROM.read(14)+(EEPROM.read(15)<<8);
int mah_alarm = EEPROM.read(16)+(EEPROM.read(17)<<8);


//========================================
// Mixed
//========================================
unsigned int mahkm =0;

unsigned char mahkmr[]={3,3,3,3,3,3};  
unsigned int mahkm_buf[5];

unsigned long long_buf=0;

unsigned char showcoordinates=1;


// Numbers and letters
unsigned char letters[] = {
// Blank - 0  
0b00000000, 
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
  
// A - 1
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b01000010,
0b01000010,
0b01000010,

// B - 2
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b01000010,
0b01000010,
0b01111110,

// C - 3
0b00000000, 
0b01111110,
0b01000000,
0b01000000,
0b01000000,
0b01000000,
0b01000000,
0b01111110,

// D - 4
0b00000000, 
0b01111000,
0b01000100,
0b01000010,
0b01000010,
0b01000010,
0b01000100,
0b01111000,

// E - 5
0b00000000, 
0b01111110,
0b01000000,
0b01000000,
0b01111110,
0b01000000,
0b01000000,
0b01111110,

// F - 6
0b00000000, 
0b01111110,
0b01000000,
0b01000000,
0b01111110,
0b01000000,
0b01000000,
0b01000000,

// G - 7
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b00000010,
0b00000010,
0b01111110,

// H - 8
0b00000000, 
0b01000010,
0b01000010,
0b01000010,
0b01111110,
0b01000010,
0b01000010,
0b01000010,

// I - 9
0b00000000, 
0b01111110,
0b00010000,
0b00010000,
0b00010000,
0b00010000,
0b00010000,
0b01111110,

// J - 10
0b00000000, 
0b01111110,
0b00000010,
0b00000010,
0b00000010,
0b01000010,
0b01100110,
0b01111100,

//K - 11
0b00000000, 
0b01000110,
0b01001000,
0b01010000,
0b01100000,
0b01010000,
0b01001000,
0b01000110,

// L - 12
0b00000000, 
0b01000000,
0b01000000,
0b01000000,
0b01000000,
0b01000000,
0b01000000,
0b01111110,

// M - 13
0b00000000, 
0b01000010,
0b01100110,
0b01011010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,

// N - 14
0b00000000, 
0b01000010,
0b01100110,
0b01010010,
0b01001010,
0b01001010,
0b01000110,
0b01000010,

// O - 15
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01111110,

// P - 16
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b01000000,
0b01000000,
0b01000000,

// Q - 17
0b00000000, 
0b01000010,
0b01100110,
0b01011010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,

// R - 18
0b00000000, 
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b01100000,
0b01011000,
0b01000110,

// S - 19
0b00000000, 
0b01111110,
0b01000000,
0b01000000,
0b01111110,
0b00000010,
0b00000010,
0b01111110,

// T - 20
0b00000000, 
0b01111110,
0b00010000,
0b00010000,
0b00010000,
0b00010000,
0b00010000,
0b00010000,

// U - 21
0b00000000, 
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01111110,

// V - 22
0b00000000, 
0b01000010,
0b01000110,
0b01000100,
0b00100100,
0b00101100,
0b00011000,
0b00011000,

// w - 23
0b00000000, 
0b10000010,
0b10010010,
0b10010010,
0b10010010,
0b10010010,
0b10010010,
0b11111110,

// x - 24
0b00000000, 
0b01000010, 
0b00100010, 
0b00010100, 
0b00001000, 
0b00010100, 
0b00100010, 
0b01000010,

// y - 25
0b00000000, 
0b01000010, 
0b00100010, 
0b00010100, 
0b00001000, 
0b00001000, 
0b00001000, 
0b00001000,

//26
0b11111111, 
0b11111111, 
0b11111111, 
0b11111111, 
0b11111111, 
0b11111111, 
0b11111111, 
0b11111111,

//27
0b11111111, 
0b00000000, 
0b00000000, 
0b00000000, 
0b00000000, 
0b00000000, 
0b00000000, 
0b11111111,

//28
0b11111110,
0b00000010,
0b00000010,
0b00000010, 
0b00000010, 
0b00000010, 
0b00000010, 
0b11111110,

//29
0b11111111,
0b10000000,
0b10000000,
0b10000000, 
0b10000000, 
0b10000000, 
0b10000000, 
0b11111111};

// Array with numbers, "-", ".", ":" and blank
char numbers[] = {
  // -  
0b00000000,
0b00000000,
0b00000000,
0b01111110,
0b01111110,
0b00000000,
0b00000000,
0b00000000, 

// .  
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00111000,
0b00111000,  
  
// /
0b00000000,
0b00000010,
0b00000010,
0b00000100,
0b00001000,
0b00010000,
0b00100000,
0b01000000,
  
// 0  
0b00000000,
0b01111110,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01000010,
0b01111110,

  // 1
0b00000000,
0b00010000,
0b00110000,
0b01010000,
0b00010000,
0b00010000,
0b00010000,
0b01111110,

// 2
0b00000000,
0b01111110,
0b00000010,
0b00000010,
0b01111110,
0b01000000,
0b01000000,
0b01111110,

// 3
0b00000000,
0b01111110,
0b00000010,
0b00000010,
0b00111110,
0b00000010,
0b00000010,
0b01111110,

// 4
0b00000000,
0b01000010,
0b01000010,
0b01000010,
0b01111110,
0b00000010,
0b00000010,
0b00000010,

// 5
0b00000000,
0b01111110,
0b01000000,
0b01000000,
0b01111110,
0b00000010,
0b00000010,
0b01111110,

// 6
0b00000000,
0b01111110,
0b01000000,
0b01000000,
0b01111110,
0b01000010,
0b01000010,
0b01111110,

// 7
0b00000000,
0b01111110,
0b01000010,
0b00000100,
0b00001000,
0b00010000,
0b00100000,
0b00100000,

// 8
0b00000000,
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b01000010,
0b01000010,
0b01111110,

// 9
0b00000000,
0b01111110,
0b01000010,
0b01000010,
0b01111110,
0b00000010,
0b00000010,
0b00000010,

0b00000000,
0b00000000,
0b00011100,
0b00011100,
0b00000000,
0b00011100,
0b00011100,
0b00000000,

0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000,
0b00000000};

// Large numbers. I prefer the large numbers, but feel free to use the smaller ones.

unsigned char LargeNumbers[] ={
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00111111,0b11111100,
0b01111111,0b11111110,
0b01111111,0b11111110,
0b01111111,0b11111110,
0b00111111,0b11111100,  
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,

// 1
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000011,0b11000000,
0b00000111,0b11100000,
0b00000111,0b11100000,
0b00000111,0b11100000,
0b00000111,0b11100000,  
0b00000011,0b11000000,

// 2
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00111000,0b00000000,
0b01111100,0b00000000,
0b01111100,0b00000000,
0b00111000,0b00000000,  
0b00000000,0b00000000, 
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00111000,0b00000000,
0b01111100,0b00000000,
0b01111100,0b00000000,
0b00111000,0b00000000,  
0b00000000,0b00000000, 
0b00000000,0b00000000,

// 3
0b00000000,0b00000000,
0b00001111,0b11110000,
0b00011111,0b11111000,
0b00111111,0b11111000,
0b01111100,0b01111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111100,0b00111100,
0b00111111,0b11111000,
0b00011111,0b11111000,
0b00001111,0b11110000,

// 4
0b00000000,0b00000000,
0b00000001,0b11000000,
0b00000111,0b11000000,
0b00001111,0b11000000,
0b00011111,0b11000000,
0b00011111,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00000011,0b11000000,
0b00011111,0b11111000,
0b00111111,0b11111100,
0b00011111,0b11111000,

// 5
0b00000000,0b00000000,
0b00001111,0b11100000,
0b00011111,0b11110000,
0b00111111,0b11111000,
0b01111000,0b00111000,
0b01110000,0b00111000,
0b00000000,0b00111000,
0b00000000,0b11111000,
0b00000001,0b11110000,
0b00000111,0b11100000,
0b00011111,0b11000000,
0b00011110,0b00000000,
0b00111100,0b00000000,
0b00111111,0b11111000,
0b01111111,0b11111100,
0b00111111,0b11111000,

// 6
0b00000000,0b00000000,
0b00001111,0b11000000,
0b00111111,0b11110000,
0b00111111,0b11111000,
0b00111000,0b01111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000011,0b11111000,
0b00000111,0b11110000,
0b00000011,0b11111000,
0b00000000,0b01111100,
0b00000000,0b00111100,
0b00111000,0b01111000,
0b01111111,0b11111000,
0b00111111,0b11110000,
0b00001111,0b11000000,


// 7
0b00000000,0b00000000,
0b00110000,0b00011000,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111000,0b00111100,
0b01111111,0b11111100,
0b01111111,0b11111100,
0b00111111,0b11111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000000,0b00011000,

// 8
0b00000000,0b00000000,
0b00111111,0b11111000,
0b01111111,0b11111100,
0b01111111,0b11111000,
0b01111000,0b00000000,
0b01111000,0b00000000,
0b01111000,0b00000000,
0b01111111,0b11100000,
0b01111111,0b11111000,
0b00111111,0b11111100,
0b00000000,0b01111100,
0b00000000,0b00111100,
0b00111000,0b01111000,
0b01111111,0b11111000,
0b00111111,0b11110000,
0b00001111,0b11000000,

// 9
0b00000000,0b00000000,
0b00001111,0b11000000,
0b00011111,0b11110000,
0b00111111,0b11111000,
0b01111100,0b00111000,
0b01111000,0b00000000,
0b01111000,0b00000000,
0b11111111,0b11000000,
0b11111111,0b11111000,
0b11111111,0b11111100,
0b11110000,0b01111100,
0b11110000,0b00111100,
0b01111000,0b01111000,
0b01111111,0b11111000,
0b00111111,0b11110000,
0b00001111,0b11000000,

// 10
0b00000000,0b00000000,
0b00111111,0b11111000,
0b01111111,0b11111100,
0b00111111,0b11111100,
0b00000000,0b00111100,
0b00000000,0b00111100,
0b00000000,0b01111000,
0b00000000,0b11111000,
0b00000000,0b11110000,
0b00000001,0b11100000,
0b00000011,0b11000000,
0b00000111,0b10000000,
0b00001111,0b00000000,
0b00011111,0b00000000,
0b00111110,0b00000000,
0b00111100,0b00000000,

// 11
0b00000000,0b00000000,
0b00000111,0b11110000,
0b00011111,0b11111000,
0b00111111,0b11111100,
0b00111000,0b00011100,
0b00111000,0b00011100,
0b00111100,0b00111100,
0b00011111,0b11111000,
0b00001111,0b11110000,
0b00011111,0b11111000,
0b00111100,0b00111100,
0b00111000,0b00011100,
0b00111000,0b00011100,
0b00111111,0b11111100,
0b00011111,0b11111000,
0b00000111,0b11110000,

// 12
0b00000000,0b00000000,
0b00000111,0b11100000,
0b00011111,0b11111000,
0b00111111,0b11111100,
0b01111100,0b00111100,
0b01111000,0b00011110,
0b01111100,0b00011110,
0b01111111,0b11111110,
0b00111111,0b11111110,
0b00000111,0b11111110,
0b00000000,0b00111110,
0b00111000,0b00111110,
0b01111100,0b01111100,
0b01111111,0b11111100,
0b00111111,0b11111100,
0b00001111,0b11110000,

// 13
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00111111,0b11111100,
0b01111111,0b11111110,
0b01111111,0b11111110,
0b01111111,0b11111110,
0b00111111,0b11111100,  
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,

// 14
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,

// 15
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00111000,0b00000000,
0b01111100,0b00000000,
0b11111110,0b00000000,
0b11111110,0b00000000,
0b01111100,0b00000000,  
0b00111000,0b00000000};


unsigned char HomeArrow[] ={
0b00000000,0b00000000,
0b00000001,0b10000000,
0b00000011,0b11000000,  
0b00000111,0b11100000,  
0b00001111,0b11110000,  
0b00011111,0b11111000,  
0b00111111,0b11111100,  
0b00111111,0b11111100,  
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000, 
0b00000001,0b10000000,  

0b00000000,0b00000000,  
0b00000000,0b00000000,  
0b00001111,0b11111110,  
0b00000111,0b11111110,  
0b00000011,0b11111110, 
0b00000001,0b11111110,
0b00000001,0b11111110,  
0b00000011,0b11111110,  
0b00000111,0b11111110,
0b00001111,0b10001110,  
0b00011111,0b00000110,  
0b00111110,0b00000010,  
0b01111100,0b00000000,  
0b11111000,0b00000000,
0b11110000,0b00000000,
0b01100000,0b00000000,

0b00000000,0b00000000,
0b00000000,0b01000000,
0b00000000,0b01100000,
0b00000000,0b01110000,
0b00000000,0b01111000,
0b00000000,0b11111100,
0b11111111,0b11111110,
0b11111111,0b11111110,
0b11111111,0b01111110,
0b11111111,0b11111110,
0b00000000,0b01111100,
0b00000000,0b01111000,
0b00000000,0b01110000,
0b00000000,0b01100000,
0b00000000,0b00000000,
0b00000000,0b00000000,

0b00000000,0b00000000,
0b00000000,0b00000000, 
0b01100000,0b00000000, 
0b11110000,0b00000000,  
0b11111000,0b00000000,
0b01111100,0b00000010,  
0b00111110,0b00000110,  
0b00011111,0b00001110, 
0b00001111,0b10011110,
0b00000111,0b11111110,  
0b00000011,0b11111110,   
0b00000001,0b11111110,    
0b00000001,0b11111110,  
0b00000011,0b11111110,   
0b00000111,0b11111110, 
0b00001111,0b11111110,

0b00000000,0b00000000,
0b00000001,0b10000000,
0b00000011,0b11000000, 
0b00000011,0b11000000, 
0b00000011,0b11000000,  
0b00000011,0b11000000,  
0b00000011,0b11000000, 
0b00000011,0b11000000,
0b00000011,0b11000000,  
0b00111111,0b11111100,  
0b00111111,0b11111100,
0b00011111,0b11111000,  
0b00001111,0b11110000,  
0b00000111,0b11100000,  
0b00000011,0b11000000,  
0b00000001,0b10000000,

0b00000000,0b00000000,
0b00000000,0b00011110,
0b00000000,0b00111110,
0b00000000,0b01111100,
0b00000000,0b11111000,
0b00000001,0b11110000,
0b01000011,0b11100000,
0b01111111,0b11000000,
0b01111111,0b10000000,
0b01111111,0b00000000,
0b01111111,0b11000000,
0b01111101,0b11100000,
0b01111111,0b11110000,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000,

0b00000000,0b00000000,
0b00000110,0b00000000,
0b00001110,0b00000000,
0b00011110,0b00000000,
0b00111110,0b00000000,
0b01111110,0b00000000,
0b11111111,0b11111100,
0b11111111,0b11111110,
0b11111111,0b11111110,
0b11111110,0b11111100,
0b01111110,0b00000000,
0b00111110,0b00000000,
0b00011110,0b00000000,
0b00001110,0b00000000,
0b00000110,0b00000000,
0b00000000,0b00000000,

0b00000000,0b00000000,
0b01111111,0b11110000,
0b01111101,0b11100000,
0b01111111,0b11000000,
0b01111111,0b00000000,
0b01111111,0b10000000,
0b01110111,0b11000000,
0b01000011,0b11100000,
0b00000001,0b11110000,
0b00000000,0b11111000,
0b00000000,0b01111100,
0b00000000,0b00111110,
0b00000000,0b00011110,
0b00000000,0b00000000,
0b00000000,0b00000000,
0b00000000,0b00000000};


/*
0b00000000,0b00000000,
0b00000001,0b10000000,
0b00000011,0b11000000,  
0b00000110,0b01100000,  
0b00001110,0b00110000,  
0b00011100,0b00011000,  
0b00110000,0b00001100,  
0b01111110,0b01111110,  
0b00111110,0b01111100,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000, 
0b00000011,0b11000000,

0b00000001,0b10000000,
0b00000011,0b11000000,  
0b00000110,0b01100000,  
0b00001110,0b00110000,  
0b00011100,0b00011000,  
0b00110000,0b00001100,  
0b01111110,0b01111110,  
0b00111110,0b01111100,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000, 
0b00000011,0b11000000,

0b00000001,0b10000000,
0b00000011,0b11000000,  
0b00000110,0b01100000,  
0b00001110,0b00110000,  
0b00011100,0b00011000,  
0b00110000,0b00001100,  
0b01111110,0b01111110,  
0b00111110,0b01111100,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000, 
0b00000011,0b11000000,

0b00000001,0b10000000,
0b00000011,0b11000000,  
0b00000110,0b01100000,  
0b00001110,0b00110000,  
0b00011100,0b00011000,  
0b00110000,0b00001100,  
0b01111110,0b01111110,  
0b00111110,0b01111100,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000,  
0b00000110,0b01100000, 
0b00000011,0b11000000};
*/


// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================
// Analog comparator interrupt:
ISR(ANALOG_COMP_vect) {
       // Reset counter
       TCNT2 =0; 

       // Wait for the sync to go high again;
       while ((ACSR & 0b00100000) == 0b00100000) { }  
      
      // If the counter has exceeded the "new line sync time", it's a new 
      // frame. In that case, we just need to reset the line-counter.  
      // 
      if (TCNT2 > 75) {
      line = 0;
      }  
  
 detectline(); 
}


void detectframe() {
         line=0;       
}



void detectline() {
         little_delay // This is used to adjust to timing when using SimpleOSD instead of Arduino


////////////////////////////////////////////
// Flight timer and mah/km
////////////////////////////////////////////

       if (line > timer_line  && line < (timer_line +17)) {  

         // Used to align the text
           _delay_loop_1(align_text);         
           
           
            temp = line - (timer_line +1);
  
            // On first line we update the buffer
            if (line == timer_line+1) {
         buffer2[0]=(flight_timer[0])<<5;   
         buffer2[1]=(flight_timer[1])<<5;   
         buffer2[2]=(flight_timer[2])<<5;          
         buffer2[3]=(flight_timer[3])<<5;  
         
         
         
            if  (show_mah_km == 1) {
                
              if (mahkmr[0]==3 && mahkmr[1]==3 && mahkmr[2]==3) {
              mahkm_buf[0]=14<<5;   
              mahkm_buf[1]=14<<5;   
              mahkm_buf[2]=14<<5;   
              mahkm_buf[3]=(mahkmr[3])<<5; 
              }   
              
             else if (mahkmr[0]==3 && mahkmr[1]==3) {
              mahkm_buf[0]=14<<5;   
              mahkm_buf[1]=14<<5;   
              mahkm_buf[2]=(mahkmr[2])<<5;          
              mahkm_buf[3]=(mahkmr[3])<<5; 
              }             
            
             else if (mahkmr[0]==3) {
              mahkm_buf[0]=14<<5;   
              mahkm_buf[1]=(mahkmr[1])<<5;   
              mahkm_buf[2]=(mahkmr[2])<<5;          
              mahkm_buf[3]=(mahkmr[3])<<5; 
              }                  
              
              else {
              mahkm_buf[0]=(mahkmr[0])<<5;   
              mahkm_buf[1]=(mahkmr[1])<<5;   
              mahkm_buf[2]=(mahkmr[2])<<5;          
              mahkm_buf[3]=(mahkmr[3])<<5;  
              }
     
              }
                        
            
            }

        
         else {
              _delay_loop_1(6);
              SPDR = LargeNumbers[buffer2[0]+2*temp];
              DimOn;
               delay13

              SPDR = LargeNumbers[buffer2[0]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[buffer2[1]+2*temp];
               delay15           

              SPDR = LargeNumbers[buffer2[1]+2*temp+1];
               delay15
               
               SPDR = LargeNumbers[64+2*temp];
               delay8

               
              SPDR = LargeNumbers[buffer2[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer2[2]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[buffer2[3]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer2[3]+2*temp+1];
               delay15             
               DimOff;
               

              if (show_plane_pos == 1) {
                _delay_loop_1(44);
               SPDR = LargeNumbers[homehead_r[0]+2*temp];
              DimOn;
              delay13

              SPDR = LargeNumbers[homehead_r[0]+2*temp+1];
              delay8
               
              SPDR = LargeNumbers[homehead_r[1]+2*temp];
               delay15        

              SPDR = LargeNumbers[homehead_r[1]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[homehead_r[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[homehead_r[2]+2*temp+1];
               delay15

              DimOff; 
 
              }

              else                {
              _delay_loop_1(84);       
              delay1         
              }
               
            if  (show_mah_km == 1) {
              
   
                 _delay_loop_1(39); // 126
                 delay1
              SPDR = LargeNumbers[mahkm_buf[0]+2*temp];
              DimOn;
              delay13

              SPDR = LargeNumbers[mahkm_buf[0]+2*temp+1];
              delay8
               
              SPDR = LargeNumbers[mahkm_buf[1]+2*temp];
               delay15        

              SPDR = LargeNumbers[mahkm_buf[1]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[mahkm_buf[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[mahkm_buf[2]+2*temp+1];
               delay8
                
              SPDR = LargeNumbers[mahkm_buf[3]+2*temp];
               delay15
               
              SPDR = LargeNumbers[mahkm_buf[3]+2*temp+1];
               delay15

              DimOff;            



            }             
           
           
            
               
               
         }
        
       }


////////////////////////////////////////////
// Flight timer END
////////////////////////////////////////////





////////////////////////////////////////////
// Top line big numbers
////////////////////////////////////////////



else if (line > toplinenumbers  && line < (toplinenumbers +17)) {
        
        // Used to align the text
         _delay_loop_1(align_text);
         _delay_loop_1(1);
         
         temp = line - (toplinenumbers +1);
                
         if (line == toplinenumbers+1) {
           
         if (los > los_alarm && flight_timer[3]%2 == 0) {
           
         buffer3[5]=14<<5;
         buffer3[6]=14<<5;
         buffer3[7]=14<<5;    
         buffer3[8]=14<<5;             
           
         }
        
          
         if (altitude_num2 > alt_alarm*10 && flight_timer[3]%2 == 0) {
           
         buffer3[9]=14<<5;
         buffer3[10]=14<<5;
         buffer3[11]=14<<5;    
         buffer3[12]=14<<5;    
         buffer3[13]=14<<5;                      
         buffer3[14]=14<<5;             
           
         }
      
         
         }
          //     _delay_loop_1(2);


         else {
           
           _delay_loop_1(3);
           
// Writes Speed

        if (show_decimals == 1) {
              SPDR = LargeNumbers[buffer3[0]+2*temp];
              DimOn;
              delay13

              SPDR = LargeNumbers[buffer3[0]+2*temp+1];
              delay8
               
              SPDR = LargeNumbers[buffer3[1]+2*temp];
               delay15        

              SPDR = LargeNumbers[buffer3[1]+2*temp+1];
               delay8
                              
               
              SPDR = LargeNumbers[buffer3[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer3[2]+2*temp+1];

                
                if (buffer3[3] != 448) {
               delay2
              SPDR = LargeNumbers[buffer3[3]+2*temp];
               delay15
                
              SPDR = LargeNumbers[buffer3[3]+2*temp+1];
               delay4
                }
                
                else {
                  DimOff;
                _delay_loop_1(10);
                delay1
                }
                
              if (buffer3[4] != 448) {
              SPDR = LargeNumbers[buffer3[4]+2*temp];
              delay15
               
              SPDR = LargeNumbers[buffer3[4]+2*temp+1];
               delay15
               DimOff;
              }
              
               else {
               DimOff;                 
               _delay_loop_1(13);
               }
               

              
        }
        
        else {
              SPDR = LargeNumbers[buffer3[0]+2*temp];
              DimOn;
              delay13

              SPDR = LargeNumbers[buffer3[0]+2*temp+1];
              delay8
               
              SPDR = LargeNumbers[buffer3[1]+2*temp];
               delay15        

              SPDR = LargeNumbers[buffer3[1]+2*temp+1];
               delay8
                              
               
              SPDR = LargeNumbers[buffer3[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer3[2]+2*temp+1];
               delay15
               
              DimOff;  
               _delay_loop_1(25);
          
          
        }
  
  // Here should be time to update the buffer for the arrow
  buffer2[11]=arrowd<<5;   
  
  // Skriver LOS tal

                 
                 if (buffer3[5] != 448) {
              SPDR = LargeNumbers[buffer3[5]+2*temp];
              DimOn;
              delay13

              SPDR = LargeNumbers[buffer3[5]+2*temp+1];
               delay4
              }
              
              else {
             _delay_loop_1(12);
              }
               
              SPDR = LargeNumbers[buffer3[6]+2*temp];
               DimOn;  
               delay13        

              SPDR = LargeNumbers[buffer3[6]+2*temp+1];
               delay8
                              
               
              SPDR = LargeNumbers[buffer3[7]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer3[7]+2*temp+1];
                delay8
                
               if (buffer3[8] != 448) {
              SPDR = LargeNumbers[buffer3[8]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer3[8]+2*temp+1];
               delay15
              DimOff;                       
               }
               
               else {
             DimOff;
             _delay_loop_1(14);
              }
               
               
         
              
        // Let's draw the arrow. 
              
        SPDR = HomeArrow[buffer2[11]+2*temp];
        DimOn;
         delay13              
        SPDR = HomeArrow[buffer2[11]+2*temp+1]; 
         delay15             
        DimOff; 
        
        
// Writes ALT              

          if (show_decimals == 1) {
//              _delay_loop_1(13);
              
              if (buffer3[9] !=448) {
              SPDR = LargeNumbers[buffer3[9]+2*temp];
              DimOn;
               delay13

              SPDR = LargeNumbers[buffer3[9]+2*temp+1];
//               delay4
              }

              else {
             _delay_loop_1(10);
              }              
              
              if (buffer3[10] != 448) {
              SPDR = LargeNumbers[buffer3[10]+2*temp];
              DimOn;
               delay13            

              SPDR = LargeNumbers[buffer3[10]+2*temp+1];
//               delay4
              }
              
              else {
             _delay_loop_1(10);
              }              

            if (buffer3[11] != 448) {
              SPDR = LargeNumbers[buffer3[11]+2*temp];
             DimOn;
               delay13
               
              SPDR = LargeNumbers[buffer3[11]+2*temp+1];
               delay8
            }

              else {
             _delay_loop_1(10);
             delay4
              }            

              SPDR = LargeNumbers[buffer3[12]+2*temp];
              DimOn;
              delay13
               
              SPDR = LargeNumbers[buffer3[12]+2*temp+1];
              delay8
               
               
              SPDR = LargeNumbers[buffer3[13]+2*temp];
              delay15
              
              SPDR = LargeNumbers[buffer3[13]+2*temp+1];
               delay8 


              SPDR = LargeNumbers[buffer3[14]+2*temp];
              delay15
              
              SPDR = LargeNumbers[buffer3[14]+2*temp+1];
               delay15               
               DimOff;
          }
          
          else {
                _delay_loop_1(37);
              SPDR = LargeNumbers[buffer3[9]+2*temp];
              DimOn;
               delay13

              SPDR = LargeNumbers[buffer3[9]+2*temp+1];
               delay8
              

              SPDR = LargeNumbers[buffer3[10]+2*temp];
               delay15            

              SPDR = LargeNumbers[buffer3[10]+2*temp+1];
               delay8
                              

              SPDR = LargeNumbers[buffer3[11]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer3[11]+2*temp+1];
               delay8
                

              SPDR = LargeNumbers[buffer3[12]+2*temp];
              delay15
               
              SPDR = LargeNumbers[buffer3[12]+2*temp+1];
              delay15 
              DimOff;
          }
          
               
         }
}  


////////////////////////////////////////////
// Top line big numbers END
////////////////////////////////////////////







////////////////////////////////////////////
// Buttom line big numbers
////////////////////////////////////////////

else if (line > butlinenumbers && line < (butlinenumbers +17)) {

            // Used to align the text
             _delay_loop_1(align_text);
  
              temp = line - (butlinenumbers +1);

               
 if (line == butlinenumbers+1) {
         if (bat_volt < volt_alarm && flight_timer[3]%2 == 0) {
           
         buffer2[8]=14<<5;
         buffer2[9]=14<<5;
         buffer2[10]=14<<5;              
           
         }
         
         
         if ((mahr[3]-3)+(mahr[2]-3)*10+(mahr[1]-3)*100+(mahr[0]-3)*1000 > mah_alarm && flight_timer[3]%2 == 0) {
         buffer2[4]=14<<5;
         buffer2[5]=14<<5;
         buffer2[6]=14<<5;              
         buffer2[7]=14<<5;            
         
       }
       
       
     }
     
     else {
         //     _delay_loop_1(3);               
             if (temp > 8) {          
                  delay5
         SPDR = letters[(3<<3)+(temp-8)];
         DimOn;
                  delay12                 
                  
         SPDR = letters[(21<<3)+(temp-8)]; 
                  delay13
         
         SPDR = letters[(18<<3)+(temp-8)];
                  delay2        
             }
             
           else {        
         _delay_loop_1(16);
         delay3         
           }  
         
              SPDR = LargeNumbers[buffer2[0]+2*temp];
              DimOn;
               delay13

              SPDR = LargeNumbers[buffer2[0]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[buffer2[1]+2*temp];
               delay15           

              SPDR = LargeNumbers[buffer2[1]+2*temp+1];
               delay15
               
               SPDR = LargeNumbers[480+2*temp];
               delay8
//               SPDR = LargeNumbers[32+2*temp+1];
//               delay13        
               
              SPDR = LargeNumbers[buffer2[2]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer2[2]+2*temp+1];
               delay15
              DimOff;
              
   
              
                _delay_loop_1(14);       
//              ==================================================

             if (temp > 8) {          
                  delay5
         SPDR = letters[(22<<3)+(temp-8)];
         DimOn;
                  delay12                 
                  
         SPDR = letters[(12<<3)+(temp-8)]; 
                  delay13
         
         SPDR = letters[(20<<3)+(temp-8)];
                  delay5        
             }
             
           else {        
         _delay_loop_1(16);
         delay8         
           }  

              SPDR = LargeNumbers[buffer2[8]+2*temp];
              DimOn;
               delay13

              SPDR = LargeNumbers[buffer2[8]+2*temp+1];
               delay8
               
              SPDR = LargeNumbers[buffer2[9]+2*temp];
               delay15           

              SPDR = LargeNumbers[buffer2[9]+2*temp+1];
               delay15
               delay2
               
               SPDR = LargeNumbers[480+2*temp];
               delay8
  
//               SPDR = LargeNumbers[32+2*temp+1];
//               delay13        
               
              SPDR = LargeNumbers[buffer2[10]+2*temp];
               delay15
               
              SPDR = LargeNumbers[buffer2[10]+2*temp+1];
               delay15
              DimOff;



// ======================================================
              

         _delay_loop_1(20);   
                        
        if (temp > 7) {                        
         SPDR = letters[(13<<3)+(temp-8)];
         DimOn;
                  delay13                 
            
         SPDR = letters[(1<<3)+(temp-8)]; 
                  delay15
         
         SPDR = letters[(8<<3)+(temp-8)];                        
                  delay11
        }
        else {
          _delay_loop_1(19);
          delay1
        }
                
              
          SPDR = LargeNumbers[buffer2[4]+2*temp];
          DimOn;
           delay15

          SPDR = LargeNumbers[buffer2[4]+2*temp+1];
           delay8 
           
           
          SPDR = LargeNumbers[buffer2[5]+2*temp];
           delay15          

          SPDR = LargeNumbers[buffer2[5]+2*temp+1];
           delay8  
           
           
          SPDR = LargeNumbers[buffer2[6]+2*temp];
           delay15
           
          SPDR = LargeNumbers[buffer2[6]+2*temp+1];
           delay8  


          SPDR = LargeNumbers[buffer2[7]+2*temp];
           delay15
           
          SPDR = LargeNumbers[buffer2[7]+2*temp+1];             
           delay15            
           DimOff;

          }
          
          
       
}

////////////////////////////////////////////
// Buttom line big numbers END
////////////////////////////////////////////









////////////////////////////////////////////
// Top line text
////////////////////////////////////////////
       else if (line > toplinetext  && line < (toplinetext +9)) {
         
       // Used to align the text
       _delay_loop_1(align_text);
         
         temp = line - (toplinetext+1);
         
          //_delay_loop_1(13);
          

         // Writes SPEED, which is the first 5 characters in the toptext array
         buffer[0]=(toptext[0])<<3;
         buffer[1]=(toptext[1])<<3;
         buffer[2]=(toptext[2])<<3;   
         buffer[3]=(toptext[3])<<3;   
         buffer[4]=(toptext[4])<<3;   

 
         // Updates SPDR (SPI buffer)
         SPDR = letters[(buffer[0])+(temp)];
         DimOn;
                 // Adds delay before the SPI buffer can be updated again. 
                 delay12   
            
         SPDR = letters[(buffer[1])+(temp)]; 
                 delay12 
         
         SPDR = letters[(buffer[2])+(temp)];
                delay13                   
                  
         SPDR = letters[(buffer[3])+(temp)];
                delay13
         
         SPDR = letters[(buffer[4])+(temp)];
                delay13
         DimOff;
         
         
         // Writes LOS (The delay loop is used to place the LOS in the middle)
          _delay_loop_1(69);
           
         buffer[0]=(toptext[5])<<3;
         buffer[1]=(toptext[6])<<3;
         buffer[2]=(toptext[7])<<3;   
         

         SPDR = letters[(buffer[0])+(temp)];
        DimOn;
                delay12   
            
         SPDR = letters[(buffer[1])+(temp)]; 
                delay13 
         
         SPDR = letters[(buffer[2])+(temp)];
                delay13
        DimOff;
         
         // Writes ALT;
          _delay_loop_1(70);
          
         buffer[0]=(toptext[8])<<3;
         buffer[1]=(toptext[9])<<3;
         buffer[2]=(toptext[10])<<3;   
         
          SPDR = letters[(buffer[0])+(temp)];
          DimOn;
                  delay13  
            
         SPDR = letters[(buffer[1])+(temp)]; 
                  delay13
         
         SPDR = letters[(buffer[2])+(temp)];
                  delay13       
         DimOff;  
       }
       
       
 ////////////////////////////////////////////
// Top line text END
////////////////////////////////////////////      
       

     else if (line > summaryline  && line < (summaryline +90)) {  
       
     // Used to align the text
     _delay_loop_1(align_text);
       
      
       if (menuon==1) {
         

         
         if (line == summaryline+1) {
         move_arrow_count++;
         if (move_arrow_count== 30) {
          move_arrow_count=0;
           
           menupos++;
           if (menupos >7) {
            menupos=1; 
           }
         }
         }
         
         if (menu==1) {
           
           temp = line - (summaryline +1);
           _delay_loop_1(13);        
           
           if (temp < 8) {


        if (temp == 0)    {
         buffer[0]=('M'-64)<<3;   
         buffer[1]=('A'-64)<<3;   
         buffer[2]=('H'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('K'-64)<<3;   
         buffer[5]=('M'-64)<<3;   
         buffer[6]=(0)<<3;
//         buffer[7]=(0)<<3;
//         buffer[8]=(0)<<3;
//         buffer[9]=(0)<<3;
        }
        
        else {
            _delay_loop_1(40);   
          if (menupos == 1) {
        SPDR = 0b11111100; numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<6;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

         _delay_loop_1(45);          
        buffer[8]=(show_mah_km+3)<<3;
        SPDR = numbers[buffer[8]+(temp)];
           _delay_loop_1(3);   

        DimOff;
        }
         
       }
       
     else if (temp > 10 && temp < 19) {
         temp = line - (summaryline +12);
           _delay_loop_1(27);     
           
           
         buffer[0]=('D'-64)<<3;   
         buffer[1]=('E'-64)<<3;   
         buffer[2]=('C'-64)<<3;   
         buffer[3]=('I'-64)<<3;   
         buffer[4]=('M'-64)<<3;   
         buffer[5]=('A'-64)<<3;   
         buffer[6]=('L'-64)<<3;   
         buffer[7]=('S'-64)<<3;   
         buffer[8]=(0)<<3;
         buffer[9]=(0)<<3;

          if (menupos == 2) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<8;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        
         _delay_loop_1(27);          
        buffer[8]=(show_decimals+3)<<3;
        SPDR = numbers[buffer[8]+(temp)];
        delay14   
        
        DimOff;
           
           
           
     }


     else if (temp > 20 && temp < 29) {
         temp = line - (summaryline +22);
           _delay_loop_1(23);     
           
           
         buffer[0]=('A'-64)<<3;   
         buffer[1]=('L'-64)<<3;   
         buffer[2]=('T'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('O'-64)<<3;   
         buffer[5]=('F'-64)<<3;   
         buffer[6]=('F'-64)<<3;   
         buffer[7]=('S'-64)<<3;   
         buffer[8]=('E'-64)<<3;   
         buffer[9]=('T'-64)<<3;   

          if (menupos == 3) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<10;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

        _delay_loop_1(12);  
        buffer[8]=(altitude_offset_on+3)<<3;
        SPDR = numbers[buffer[8]+(temp)];
        delay14   
        
        DimOff;
           
           
           
           
     }      
     
     
     
          else if (temp > 30 && temp < 39) {
         temp = line - (summaryline +32);

           if (temp == 0) {
         buffer[10]=((align_text/10)+3)<<3;   
         buffer[11]=((align_text%10)+3)<<3;             
           }
           
          
           else {
           _delay_loop_1(19);    
           
         buffer[0]=('T'-64)<<3;   
         buffer[1]=('E'-64)<<3;   
         buffer[2]=('X'-64)<<3;   
         buffer[3]=('T'-64)<<3;   
         buffer[4]=(0)<<3;   
         buffer[5]=('A'-64)<<3;   
         buffer[6]=('L'-64)<<3;   
         buffer[7]=('I'-64)<<3;   
         buffer[8]=('G'-64)<<3;   
         buffer[9]=('N'-64)<<3;   

          if (menupos == 4) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<10;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        

         _delay_loop_1(7);  
        SPDR = numbers[buffer[10]+(temp)];
        delay15
        SPDR = numbers[buffer[11]+(temp)];
        delay14
        
        DimOff;
           
          }
           
     }


     else if (temp > 40 && temp < 49) {
         temp = line - (summaryline +42);
           _delay_loop_1(18);     
           
         buffer[0]=('P'-64)<<3;   
         buffer[1]=('L'-64)<<3;   
         buffer[2]=('A'-64)<<3;   
         buffer[3]=('N'-64)<<3;   
         buffer[4]=('E'-64)<<3;   
         buffer[5]=('P'-64)<<3;   
         buffer[6]=('O'-64)<<3;   
         buffer[7]=('S'-64)<<3;   
         buffer[8]=(0)<<3;   
         buffer[9]=(0)<<3;   

          if (menupos == 5) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<8;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

         _delay_loop_1(28);          
        buffer[8]=(show_plane_pos+3)<<3;
        SPDR = numbers[buffer[8]+(temp)];
        delay14           
        DimOff
           
           
           
     }



     else if (temp > 50 && temp < 59) {
         temp = line - (summaryline +52);
           _delay_loop_1(16);     

         buffer[0]=('S'-64)<<3;   
         buffer[1]=('E'-64)<<3;   
         buffer[2]=('T'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('A'-64)<<3;   
         buffer[5]=('L'-64)<<3;   
         buffer[6]=('A'-64)<<3;   
         buffer[7]=('R'-64)<<3;   
         buffer[8]=('M'-64)<<3;   
         buffer[9]=('S'-64)<<3;   

          if (menupos == 6) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<10;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        _delay_loop_1(3);              
        DimOff
           
           
     }


     else if (temp > 60 && temp < 69) {
         temp = line - (summaryline +62);
           _delay_loop_1(18);     
           
           
         buffer[0]=('E'-64)<<3;   
         buffer[1]=('X'-64)<<3;   
         buffer[2]=('I'-64)<<3;   
         buffer[3]=('T'-64)<<3;   
         buffer[4]=(0)<<3;            


          if (menupos == 7) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<4;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        DimOff;
           
           
           
     }            
       
       
       }
       
       if (menu == 2) {
         
         
         
         
         
temp = line - (summaryline +1);
        //   _delay_loop_1(13);        
           
           if (temp < 8) {



if (temp == 0) {

         buffer[0]=('A'-64)<<3;   
         buffer[1]=('L'-64)<<3;   
         buffer[2]=('T'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('A'-64)<<3;   
         buffer[5]=('L'-64)<<3;   
         buffer[6]=('A'-64)<<3;   
         buffer[7]=('R'-64)<<3;   
         buffer[8]=('M'-64)<<3;   
         buffer[9]=(0)<<3; 
}

      else {
         _delay_loop_1(50);   
          if (menupos == 1) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<10;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

        _delay_loop_1(6);  
        for (ii=0;ii<4;ii++) {
        SPDR = numbers[GPSbuffer[ii]+(temp)];       
        }
        _delay_loop_1(3);  
        DimOff;
      }
          
         
       }
       
     else if (temp > 10 && temp < 19) {
         temp = line - (summaryline +12);
           _delay_loop_1(37);     
           
           
         buffer[0]=('L'-64)<<3;   
         buffer[1]=('O'-64)<<3;   
         buffer[2]=('S'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('A'-64)<<3;   
         buffer[5]=('L'-64)<<3;   
         buffer[6]=('A'-64)<<3;   
         buffer[7]=('R'-64)<<3;   
         buffer[8]=('M'-64)<<3;   
         buffer[9]=(0)<<3;

          if (menupos == 2) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<9;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        
        _delay_loop_1(16);  
        for (ii=4;ii<8;ii++) {
        SPDR = numbers[GPSbuffer[ii]+(temp)];       
        }
        _delay_loop_1(3);  
        DimOff;
           
           
           
     }


     else if (temp > 20 && temp < 29) {
         temp = line - (summaryline +22);
           _delay_loop_1(34);     
           
           
         buffer[0]=('V'-64)<<3;   
         buffer[1]=('O'-64)<<3;   
         buffer[2]=('L'-64)<<3;   
         buffer[3]=('T'-64)<<3;   
         buffer[4]=(0)<<3;   
         buffer[5]=('A'-64)<<3;   
         buffer[6]=('L'-64)<<3;   
         buffer[7]=('A'-64)<<3;   
         buffer[8]=('R'-64)<<3;   
         buffer[9]=('M'-64)<<3;   

          if (menupos == 3) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<10;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

        _delay_loop_1(17);  
        for (ii=9;ii<12;ii++) {
        SPDR = numbers[GPSbuffer[ii]+(temp)];       
        }
        _delay_loop_1(3);  
        DimOff;
           
           
           
           
     }      
     
     
     
          else if (temp > 30 && temp < 39) {
         temp = line - (summaryline +32);

           if (temp == 0) {
         buffer[9]=((align_text/10)+3)<<3;   
         buffer[10]=((align_text%10)+3)<<3;             
           }
           
          
           else {
           _delay_loop_1(31);    
           
         buffer[0]=('M'-64)<<3;   
         buffer[1]=('A'-64)<<3;   
         buffer[2]=('H'-64)<<3;   
         buffer[3]=(0)<<3;   
         buffer[4]=('A'-64)<<3;   
         buffer[5]=('L'-64)<<3;   
         buffer[6]=('A'-64)<<3;   
         buffer[7]=('R'-64)<<3;   
         buffer[8]=('M'-64)<<3;   

          if (menupos == 4) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<9;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  

        _delay_loop_1(17);  
        for (ii=12;ii<16;ii++) {
        SPDR = numbers[GPSbuffer[ii]+(temp)];       
        }
        _delay_loop_1(3);
        DimOff;
           
          }
           
     }




     else if (temp > 60 && temp < 69) {
         temp = line - (summaryline +62);
           _delay_loop_1(33);     
           
           
         buffer[0]=('E'-64)<<3;   
         buffer[1]=('X'-64)<<3;   
         buffer[2]=('I'-64)<<3;   
         buffer[3]=('T'-64)<<3;   
         buffer[4]=(0)<<3;            


          if (menupos == 5) {
        SPDR = 0b11111100; //numbers[0+(temp)];
           _delay_loop_1(3);       
          }
          else {
        SPDR = 0b00000000;
           _delay_loop_1(3);       
          }       
                            
        DimOn;                    
        for (ii=0;ii<4;ii++) {
        SPDR = letters[buffer[ii]+(temp)];       
        }  
        DimOff;
           
           
           
     }         
         
         


         
         
         
       }
       
       
       
       
       }

       else if (homepos ==0) {
           
            temp = line - (summaryline +1);
           _delay_loop_1(10);        
           if (temp < 8) {

           _delay_loop_1(65);                     

         buffer[0]=('S'-64)<<3;   
         buffer[1]=('A'-64)<<3;   
         buffer[2]=('T'-64)<<3;          
         
         buffer[3]=satellitesr[0]<<3;
         buffer[4]=satellitesr[1]<<3;

        DimOn;
        for (ii=0;ii<3;ii++) {
        SPDR=letters[buffer[ii]+(temp)];
      }  
        
        // Writes ':'
        SPDR = numbers[104+temp];
        _delay_loop_1(6);
        
      for (ii=3;ii<5;ii++) {
      SPDR=numbers[buffer[ii]+(temp)];
      }            
      _delay_loop_1(2);
        DimOff;      
        
         }
         
         
     if (temp > 10 && temp < 19) {
         temp = line - (summaryline +12);
        _delay_loop_1(41);           
       
         buffer[0]=('G'-64)<<3;   
         buffer[1]=('P'-64)<<3;   
         buffer[2]=('S'-64)<<3;          
         
         buffer[3]=('F'-64)<<3;   
         buffer[4]=('I'-64)<<3;   
         buffer[5]=('X'-64)<<3;           
         
         DimOn;
        for (ii=0;ii<6;ii++) {
        SPDR=letters[buffer[ii]+(temp)];
        }     
        
        SPDR = numbers[104+temp];
        _delay_loop_1(6);              

       if (GPSfix > '0') {
         buffer[0]=('Y'-64)<<3;   
         buffer[1]=('E'-64)<<3;   
         buffer[2]=('S'-64)<<3;          

       }         
       
       else {
         buffer[0]=('N'-64)<<3;   
         buffer[1]=('O'-64)<<3;   
         buffer[2]=('@'-64)<<3;          

         
       }

        for (ii=0;ii<3;ii++) {
        SPDR=letters[buffer[ii]+(temp)];
        }     
         _delay_loop_1(3);
        DimOff;   
        
        
       
         
           }
  
  
         if  (temp == 19) {
           
       test = (homeposcount *10) / set_home_delay;
       for (i=0;i<test;i++) {
       loadbar[i]=26;
        }
      // SPDR=0b11111110;        
           
         }
         
      if (temp == 20) {
        
        
       for (ii=0;ii<9;ii++) {
         buffer[ii]=(loadbar[ii])<<3;   
        }
        
        /*
         buffer[0]=(loadbar[0])<<3;   
         buffer[1]=(loadbar[1])<<3;   
         buffer[2]=(loadbar[2])<<3;          
         buffer[3]=(loadbar[3])<<3;   
         buffer[4]=(loadbar[4])<<3;   
         buffer[5]=(loadbar[5])<<3;    
         buffer[6]=(loadbar[6])<<3;   
         buffer[7]=(loadbar[7])<<3;   
         buffer[8]=(loadbar[8])<<3;    
         */
         buffer[9]=(28)<<3;         
       
       
         buffer[10]=('D'-64)<<3;    
         buffer[11]=('E'-64)<<3;   
         buffer[12]=('L'-64)<<3;   
         buffer[13]=('A'-64)<<3;    
         buffer[14]=('Y'-64)<<3;             
      }  
  
  
  
         if (temp > 31 && temp < 40) {
         temp = line - (summaryline +33);
         _delay_loop_1(57);  

DimOn;
for (ii=10;ii<15;ii++) {
        SPDR = letters[buffer[ii]+(temp)];  
  
}
_delay_loop_1(3);
/*
        DimOn
        delay15
        SPDR = letters[buffer[11]+(temp)];
        delay15
        SPDR = letters[buffer[12]+(temp)];
        delay15
        SPDR = letters[buffer[13]+(temp)];
        delay15
        SPDR = letters[buffer[14]+(temp)];
        delay15   
        */

        // Writes ':'
        SPDR = numbers[104+temp];
        _delay_loop_1(9);        

        DimOff;
        

        
           }

           if (temp > 42 && temp < 51) {
             
         _delay_loop_1(30);               
         temp = line - (summaryline +44);           


        for (ii=0;ii<10;ii++) {
        SPDR=letters[buffer[ii]+(temp)];
        DimOn;        
        }     
         _delay_loop_1(3);               
        DimOff;
         
         /*
        SPDR = letters[buffer[0]+(temp)];
        DimOn;       
        delay11
        SPDR = letters[buffer[1]+(temp)];
        delay15
        SPDR = letters[buffer[2]+(temp)];
        delay15 
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay15
        SPDR = letters[buffer[6]+(temp)];
        delay15
        SPDR = letters[buffer[7]+(temp)];
        delay15
        SPDR = letters[buffer[8]+(temp)];
        delay15
        SPDR = letters[buffer[9]+(temp)];
        delay13             
        DimOff   
           */
         }
         
         
           if (temp > 64 && temp < 73) {
         temp = line - (summaryline +66);
         _delay_loop_1(25);                  
         
// Stores all the time-numbers in a temporary buffer.   
  if (temp == 0) {
        for (ii=0;ii<11;ii++) {
        buffer[ii]=time[ii]<<3;
        }     
  }

/*
         buffer[0]=time[0]<<3;
         buffer[1]=time[1]<<3;
//         buffer[2]=13<<3;   
         buffer[3]=time[2]<<3;
         buffer[4]=time[3]<<3;          
//         buffer[5]=13<<3;
         buffer[6]=time[4]<<3;
         buffer[7]=time[5]<<3;   
         */
    //     buffer[6]=time[6]<<3;
  //       buffer[7]=time[7]<<3;            
//         buffer[8]=time[8]<<3;  
   
   else {      
         // Shift out first 8 bit
        
        DimOn;         
        for (ii=0;ii<2;ii++) {
        SPDR=numbers[buffer[ii]+(temp)];
        }     
        
        
        /*
         SPDR = numbers[(buffer[0])+(temp)];
         
         //Turns on dimming, will be almost at first pixel. 
          DimOn;
          delay12                     
            
         SPDR = numbers[(buffer[1])+(temp)]; 
           delay11                  
         */

         _delay_loop_1(3);                       
         SPDR = numbers[(104)+(temp)];
//           delay12     

        for (ii=2;ii<4;ii++) {
        SPDR=numbers[buffer[ii]+(temp)];
        }     
        
         /*
         SPDR = numbers[(buffer[2])+(temp)];
           delay12                   
              
         SPDR = numbers[(buffer[3])+(temp)];
                  delay15
                  delay3                  
                  */
                  
         _delay_loop_1(3);                      
         SPDR = numbers[(104)+(temp)];
//         _delay_loop_1(3);                


        for (ii=4;ii<9;ii++) {
        SPDR=numbers[buffer[ii]+(temp)];
        }     

               /*   
         SPDR = numbers[(buffer[4])+(temp)];
                  delay13             
         SPDR = numbers[(buffer[5])+(temp)]; 
              delay13      
              
           
         SPDR = numbers[(buffer[6])+(temp)]; 
              delay13     

         SPDR = numbers[(buffer[7])+(temp)]; 
              delay13     

         SPDR = numbers[(buffer[8])+(temp)]; 
              delay13    
             */ 
         _delay_loop_1(3);              
         DimOff;   
          }
           }   
        
        
           if (temp > 80 && temp < 89) {
         temp = line - (summaryline +82);
         _delay_loop_1(18);                 
         
         buffer[0]=('V'-64)<<3;   
         buffer[1]=('E'-64)<<3;   
         buffer[2]=('R'-64)<<3;    
         buffer[3]=('S'-64)<<3;    
         buffer[4]=('I'-64)<<3;   
         buffer[5]=('O'-64)<<3;    
         buffer[6]=('N'-64)<<3; 

         buffer[7]=(0+3)<<3;    
         buffer[8]=(1+3)<<3;   
         buffer[9]=(3+5)<<3;    

        DimOn;
        for (ii=0;ii<7;ii++) {
        SPDR=letters[buffer[ii]+(temp)];
        }     
         _delay_loop_1(3);               

        
/*         
        SPDR = letters[buffer[0]+(temp)];
        DimOn;       
        delay14
        SPDR = letters[buffer[1]+(temp)];
        delay15
        SPDR = letters[buffer[2]+(temp)];
        delay15 
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay15
        SPDR = letters[buffer[6]+(temp)];
        delay15           
        delay15
    */
    
         SPDR = numbers[(buffer[7])+(temp)];
         delay15             
         SPDR = numbers[8+(temp)]; 
         delay15      
         SPDR = numbers[(buffer[8])+(temp)];
         delay15             
         SPDR = numbers[(buffer[9])+(temp)]; 
         delay15                  
         DimOff             
              
       
           }  
                 
         
         
         
         
         
        }
         
         else {
         
         if (landed == 1) {
         _delay_loop_1(25);                 
               temp = line - (summaryline +1);
               
           if (temp < 8) {
         _delay_loop_1(30);      
         buffer[0]=('M'-64)<<3;   
         buffer[1]=('A'-64)<<3;   
         buffer[2]=('X'-64)<<3;          
         
         buffer[3]=('A'-64)<<3;   
         buffer[4]=('L'-64)<<3;   
         buffer[5]=('T'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;
        delay14        
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13     

         buffer[0]=(max_altr[0])<<3;   
         buffer[1]=(max_altr[1])<<3;   
         buffer[2]=(max_altr[2])<<3;          
         buffer[3]=(max_altr[3])<<3;                
         buffer[4]=(max_altr[4])<<3;                
             
             
        SPDR = numbers[buffer[0]+(temp)];
        delay13 
        SPDR = numbers[buffer[1]+(temp)];
        delay13
        SPDR = numbers[buffer[2]+(temp)];
        delay13   
        SPDR = numbers[buffer[3]+(temp)];
        delay13         
        
        SPDR = numbers[8+(temp)];
        delay13         
        
        SPDR = numbers[buffer[4]+(temp)];
        delay13              
        DimOff; 
        
         }
           
           if (temp > 10 && temp < 19) {
         temp = line - (summaryline +11);
        _delay_loop_1(23);           

 
//         buffer[0]=('M'-64)<<3;   
//         buffer[1]=('A'-64)<<3;   
//         buffer[2]=('X'-64)<<3;          
         
         buffer[3]=('S'-64)<<3;   
         buffer[4]=('P'-64)<<3;   
         buffer[5]=('D'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;       
        delay13
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13 
        
        
         buffer[0]=(max_speedr[0])<<3;   
         buffer[1]=(max_speedr[1])<<3;   
         buffer[2]=(max_speedr[2])<<3;          
         buffer[3]=(max_speedr[3])<<3;                
             
        _delay_loop_1(2);                                 
        delay1
        
        SPDR = numbers[buffer[0]+(temp)];
        delay13
        SPDR = numbers[buffer[1]+(temp)];
        delay13
        SPDR = numbers[buffer[2]+(temp)];
        delay15
        SPDR = numbers[8+(temp)];   
        delay13        
        SPDR = numbers[buffer[3]+(temp)];
        delay13  
        DimOff;       
         
           }
           
           if (temp > 20 && temp < 29) {
         temp = line - (summaryline +21);
         _delay_loop_1(19);  


//         buffer[0]=('M'-64)<<3;   
//         buffer[1]=('A'-64)<<3;   
//         buffer[2]=('X'-64)<<3;          
         
         buffer[3]=('L'-64)<<3;   
         buffer[4]=('O'-64)<<3;   
         buffer[5]=('S'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay13
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13         
             
         buffer[0]=(max_losr[0])<<3;   
         buffer[1]=(max_losr[1])<<3;   
         buffer[2]=(max_losr[2])<<3;          
         buffer[3]=(max_losr[3])<<3;                
             
        _delay_loop_1(2);                    
        delay2
        
        SPDR = numbers[buffer[0]+(temp)];
        delay13
        SPDR = numbers[buffer[1]+(temp)];
        delay13
        SPDR = numbers[buffer[2]+(temp)];
        delay13   
        SPDR = numbers[buffer[3]+(temp)];
        delay13             
        DimOff; 
        
           }           

           if (temp > 31 && temp < 40) {
         temp = line - (summaryline +32);
         _delay_loop_1(15);
         delay1
         
         buffer[0]=('T'-64)<<3;   
         buffer[1]=('O'-64)<<3;   
         buffer[2]=('T'-64)<<3;          
         
         buffer[3]=('D'-64)<<3;   
         buffer[4]=('I'-64)<<3;   
         buffer[5]=('S'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay9
        SPDR = letters[buffer[1]+(temp)];
        delay15
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15      
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13 


         buffer[0]=(total_distancer[0])<<3;   
         buffer[1]=(total_distancer[1])<<3;   
         buffer[2]=(total_distancer[2])<<3;          
         buffer[3]=(total_distancer[3])<<3;                
         buffer[4]=(total_distancer[4])<<3;          
             
        _delay_loop_1(1);                    
        delay1
        
        SPDR = numbers[buffer[0]+(temp)];
        delay13
        SPDR = numbers[buffer[1]+(temp)];
        delay13

        SPDR = numbers[buffer[2]+(temp)];
        delay13   
        SPDR = numbers[buffer[3]+(temp)];
        delay14     
        SPDR = numbers[buffer[4]+(temp)];
        delay13             
        DimOff; 

      
           }           
           
           if (temp > 42 && temp < 51) {
         temp = line - (summaryline +43);
         _delay_loop_1(14);                  

         
         buffer[0]=('T'-64)<<3;   
         buffer[1]=('I'-64)<<3;   
         buffer[2]=('M'-64)<<3;          
         buffer[3]=('E'-64)<<3;   
          
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay13
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
        delay15   
        SPDR = letters[buffer[3]+(temp)];
        delay13

         buffer[0]=(flight_timer[0])<<3;   
         buffer[1]=(flight_timer[1])<<3;   
         buffer[2]=(flight_timer[2])<<3;          
         buffer[3]=(flight_timer[3])<<3;                
             
        _delay_loop_1(20);
        delay2        

        
        SPDR = numbers[buffer[0]+(temp)];
        delay13
        SPDR = numbers[buffer[1]+(temp)];
        delay13
        
        SPDR = numbers[104+(temp)];
        delay13
        
        
        SPDR = numbers[buffer[2]+(temp)];
        delay13   
        SPDR = numbers[buffer[3]+(temp)];
        delay13      
        DimOff; 

           }           
           
           if (temp > 53 && temp < 62) {
         temp = line - (summaryline +54);
         _delay_loop_1(9);                  
         
         buffer[0]=('A'-64)<<3;   
         buffer[1]=('V'-64)<<3;   
         buffer[2]=('G'-64)<<3;          
         
         buffer[3]=('S'-64)<<3;   
         buffer[4]=('P'-64)<<3;   
         buffer[5]=('D'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay11
        SPDR = letters[buffer[1]+(temp)];
        delay15
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13 
        
        
         buffer[0]=(avg_speedr[0])<<3;   
         buffer[1]=(avg_speedr[1])<<3;   
         buffer[2]=(avg_speedr[2])<<3;          
         buffer[3]=(avg_speedr[3])<<3;                
             
        _delay_loop_1(1);                    
        delay2
        
        SPDR = numbers[buffer[0]+(temp)];
        delay13
        SPDR = numbers[buffer[1]+(temp)];
        delay13
        
        SPDR = numbers[buffer[2]+(temp)];
        delay13
        
        SPDR = numbers[8+(temp)];
        delay13        
        
        SPDR = numbers[buffer[3]+(temp)];
        delay13      
        DimOff;         
        
           }

           if (temp > 64 && temp < 73 && 1==0) {
         temp = line - (summaryline +65);
         _delay_loop_1(4);         
                  
         buffer[0]=('@'-64)<<3;   
         buffer[1]=('@'-64)<<3;   
         buffer[2]=('@'-64)<<3;          
         
         buffer[3]=('@'-64)<<3;   
         buffer[4]=('@'-64)<<3;   
         buffer[5]=('@'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay13
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay13
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13 
        DimOff;         

           }           
           
           if (temp > 75 && temp < 84 && 1==0) {
         temp = line - (summaryline +76);
         
         buffer[0]=('@'-64)<<3;   
         buffer[1]=('@'-64)<<3;   
         buffer[2]=('@'-64)<<3;          
         
         buffer[3]=('@'-64)<<3;   
         buffer[4]=('@'-64)<<3;   
         buffer[5]=('@'-64)<<3;           
         
        
        SPDR = letters[buffer[0]+(temp)];
        DimOn;        
        delay13
        SPDR = letters[buffer[1]+(temp)];
        delay13
        SPDR = letters[buffer[2]+(temp)];
 
        
        _delay_loop_1(10);      
        SPDR = letters[buffer[3]+(temp)];
        delay15
        SPDR = letters[buffer[4]+(temp)];
        delay15
        SPDR = letters[buffer[5]+(temp)];
        delay13 
        DimOff; 
        
           }             
           
         }
         
         
        }
       }      
      
      

   else if (line > gps_nmea_line  && line < (gps_nmea_line +9)) {

     // Used to align the text
     _delay_loop_1(align_text);     
       
     
     if (line == (gps_nmea_line+1)) {
     if (altitude_num2 < show_gps_coordinates_altitude*10  | flight_timer[3] % show_gps_coordinates_second == 0) {

    // _delay_loop_1(22);
         showcoordinates=1;         
     }
     
     else {
         showcoordinates=0; 
     }
  
     }
     
     else if (showcoordinates == 1) {
           _delay_loop_1(8);
         buffer[0]=(latitude[0]-45)<<3;
         buffer[1]=(latitude[1]-45)<<3;
         buffer[2]=(latitude[2]-45)<<3;
         buffer[3]=(latitude[3]-45)<<3;
         buffer[4]=(latitude[4]-45)<<3;         
         buffer[5]=(latitude[5]-45)<<3;
         buffer[6]=(latitude[6]-45)<<3;
         buffer[7]=(latitude[7]-45)<<3;         
         buffer[8]=(latitude[8]-45)<<3;                  
         buffer[9]=(latitude[9]-45)<<3;        
         
            temp = line - (gps_nmea_line+1);
         // Updates SPDR (SPI buffer)
         SPDR = numbers[(buffer[0])+(temp)];
         DimOn;
                 delay12
            
         SPDR = numbers[(buffer[1])+(temp)]; 
                 delay12 

         SPDR = numbers[(buffer[2])+(temp)]; 
                 delay12         
                
         SPDR = numbers[(buffer[3])+(temp)];
                delay13      
                
                
                
         SPDR = numbers[(buffer[4])+(temp)]; 
                 delay12 

         SPDR = numbers[(buffer[5])+(temp)]; 
                delay13         
                
         SPDR = numbers[(buffer[6])+(temp)];
                delay13     
                
         SPDR = numbers[(buffer[7])+(temp)];
                delay13         
    
         SPDR = numbers[(buffer[8])+(temp)];
                delay13             
       
         SPDR = numbers[(buffer[9])+(temp)];
                delay13         

         buffer[10]=(latitude_dir)<<3;     
         SPDR = letters[(buffer[10])+(temp)];
                delay13                
                
          DimOff;


//     _delay_loop_1(8);
         buffer[0]=(longitude[0]-45)<<3;
         buffer[1]=(longitude[1]-45)<<3;
         buffer[2]=(longitude[2]-45)<<3;
         buffer[3]=(longitude[3]-45)<<3;
         buffer[4]=(longitude[4]-45)<<3;         
         buffer[5]=(longitude[5]-45)<<3;
         buffer[6]=(longitude[6]-45)<<3;
         buffer[7]=(longitude[7]-45)<<3;         
         buffer[8]=(longitude[8]-45)<<3;                  
         buffer[9]=(longitude[9]-45)<<3;                                  
     
         
         
         // Updates SPDR (SPI buffer)
         SPDR = numbers[(buffer[0])+(temp)];
         DimOn;
                 delay12
            
         SPDR = numbers[(buffer[1])+(temp)]; 
                 delay12 

         SPDR = numbers[(buffer[2])+(temp)]; 
                 delay12         
                
         SPDR = numbers[(buffer[3])+(temp)];
                delay13      
                
                
                
         SPDR = numbers[(buffer[4])+(temp)]; 
                 delay12 

         SPDR = numbers[(buffer[5])+(temp)]; 
                delay13         
                
         SPDR = numbers[(buffer[6])+(temp)];
                delay13     
                
         SPDR = numbers[(buffer[7])+(temp)];
                delay13         
    
         SPDR = numbers[(buffer[8])+(temp)];
                delay13             
       
         SPDR = numbers[(buffer[9])+(temp)];
                delay13    

         buffer[10]=(longitude_dir)<<3;       
         SPDR = letters[(buffer[10])+(temp)];
                delay13
             DimOff;
             
     
             
     }
   }





 else if (line == toplinenumbers) {
         
         
         if (speedkmw[0]==3 && speedkmw[1]==3) {
         buffer3[0]=speedkmw[2]<<5;   
         buffer3[1]=1<<5;
         buffer3[2]=speedkmw[3]<<5;    
         buffer3[3]=14<<5;
         buffer3[4]=14<<5;
          
         }
         
         else if (speedkmw[0]==3) {
         buffer3[0]=speedkmw[1]<<5;
         buffer3[1]=speedkmw[2]<<5;   
         buffer3[2]=1<<5;
         buffer3[3]=speedkmw[3]<<5;  
         buffer3[4]=14<<5;
         
         if (show_decimals == 0) {
         buffer3[2]=14<<5;
           }
  
         }
         
         else {
         buffer3[0]=speedkmw[0]<<5;
         buffer3[1]=speedkmw[1]<<5;
         buffer3[2]=speedkmw[2]<<5;   
         buffer3[3]=1<<5;
         buffer3[4]=speedkmw[3]<<5;          
         }
         
         
         buffer3[5]=losr[0]<<5;
         buffer3[6]=losr[1]<<5;
         buffer3[7]=losr[2]<<5;   
         buffer3[8]=losr[3]<<5;
         
        if (losr[0] == 3 && losr[1] == 3) {
         buffer3[5]=14<<5;
         buffer3[6]=losr[2]<<5;
         buffer3[7]=losr[3]<<5;   
         buffer3[8]=14<<5;
        }       
        
        else if (losr[0] == 3) {
         buffer3[5]=14<<5;
         buffer3[6]=losr[1]<<5;
         buffer3[7]=losr[2]<<5;   
         buffer3[8]=losr[3]<<5;
        }

  if (altitude_offset_on ==0) {
        if (altitude2[3] == 14) {
         buffer3[9] =14<<5;    
         buffer3[10]=14<<5;         
         buffer3[11]=14<<5;        
         buffer3[12]=altitude2[0]<<5;                
         buffer3[13]=altitude2[1]<<5;
         buffer3[14]=altitude2[2]<<5;   
        }
        
        else if (altitude2[4] == 14) {
         buffer3[9] =14<<5;    
         buffer3[10]=14<<5;         
         buffer3[11]=altitude2[0]<<5;        
         buffer3[12]=altitude2[1]<<5;                
         buffer3[13]=altitude2[2]<<5;
         buffer3[14]=altitude2[3]<<5;   
        }       
       
         else if (altitude2[5] == 14) {
         buffer3[9] =14<<5;    
         buffer3[10]=altitude2[0]<<5;         
         buffer3[11]=altitude2[1]<<5;        
         buffer3[12]=altitude2[2]<<5;                
         buffer3[13]=altitude2[3]<<5;
         buffer3[14]=altitude2[4]<<5;   
        }  
        
         else  {
         buffer3[9] =altitude2[0]<<5;    
         buffer3[10]=altitude2[1]<<5;         
         buffer3[11]=altitude2[2]<<5;        
         buffer3[12]=altitude2[3]<<5;                
         buffer3[13]=altitude2[4]<<5;
         buffer3[14]=altitude2[5]<<5;
        }
        
  }
  else {


        if (altituder[0] == 3 && altituder[1] == 3 && altituder[2]==3 ) {
         buffer3[9] =14<<5;    
         buffer3[10]=14<<5;         
         buffer3[11]=14<<5;        
         buffer3[12]=altituder[3]<<5;                
    //     buffer3[13]=altituder[3]<<5;
         buffer3[14]=altituder[4]<<5;   
        }
        
        else if (altituder[0] == 3 && altituder[1] == 3) {
         buffer3[9] =14<<5;    
         buffer3[10]=14<<5;         
         buffer3[11]=altituder[2]<<5;        
         buffer3[12]=altituder[3]<<5;                
   //      buffer3[13]=altituder[3]<<5;
         buffer3[14]=altituder[4]<<5;   
        }       
       
         else if (altituder[0] == 3) {
         buffer3[9] =14<<5;    
         buffer3[10]=altituder[1]<<5;         
         buffer3[11]=altituder[2]<<5;        
         buffer3[12]=altituder[3]<<5;                
  //       buffer3[13]=altituder[3]<<5;
         buffer3[14]=altituder[4]<<5;   
        }  
        
         else  {
         buffer3[9] =altituder[0]<<5;    
         buffer3[10]=altituder[1]<<5;         
         buffer3[11]=altituder[2]<<5;        
         buffer3[12]=altituder[3]<<5;                
//       buffer3[13]=altituder[4]<<5;
         buffer3[14]=altituder[4]<<5;
        }
       
         buffer3[13]=1<<5;
         
       if (altitude_negative ==1) {
         buffer3[9] =16<<5;              
        }         
         
  }
}
         
// ============================================================
// Buttom line text
// ============================================================
   
else if (line == butlinenumbers ) {

         
         if (currentr[0]== 3) {
         buffer2[0]=14<<5;
         buffer2[1]=currentr[1]<<5;
         buffer2[2]=currentr[3]<<5; 
         }
         
         else {
         buffer2[0]=currentr[0]<<5;
         buffer2[1]=currentr[1]<<5;
         buffer2[2]=currentr[3]<<5;           
         }
         

         if (mahr[0]==3 && mahr[1]==3 && mahr[2]==3) {
         buffer2[4]=14<<5;
         buffer2[5]=14<<5;
         buffer2[6]=14<<5;              
         buffer2[7]=mahr[3]<<5;           
         }
         
         else if (mahr[0]==3 && mahr[1] ==3) {
         buffer2[4]=14<<5;
         buffer2[5]=14<<5;
         buffer2[6]=mahr[2]<<5;              
         buffer2[7]=mahr[3]<<5;           
         }   
         
         else if (mahr[0]==3) {
         buffer2[4]=14<<5;
         buffer2[5]=mahr[1]<<5;
         buffer2[6]=mahr[2]<<5;              
         buffer2[7]=mahr[3]<<5;            
         }
   
         else {
         buffer2[4]=mahr[0]<<5;
         buffer2[5]=mahr[1]<<5;
         buffer2[6]=mahr[2]<<5;              
         buffer2[7]=mahr[3]<<5;     
         }      
         
         buffer2[8]=voltager[0]<<5;
         buffer2[9]=voltager[1]<<5;
         buffer2[10]=voltager[3]<<5;         

         temp = (arrowr[0]-3)*100+(arrowr[1]-3)*10+(arrowr[0]-3);      

// Determine what way the arrow should point
           for (i=0;i<8;i++) {
            if (temp < (23+45*i)) {
              arrowd = i;
              break;
            } 
           }
            
            if ( temp > 360-23) { arrowd =0;}     
}


        
// ============================================================
// Buttom line text END
// ============================================================
          
       
       
// As a quick and dirty implementation the timing from the video-signal
// is used to calculate the power consumption (mAh). But if it looses sync you
// wan't even be able to see any text - so this should de fine.
// Maybe not the best way to do it, but this way I know when it does what. 
// ============================================================
// Current sensor
// ============================================================ 

// As the calculations takes quite a while they will be done after last line with text. 
// Otherwise the text will "jump a bit". We might miss a line or two - but as it is in
// the buttom of the screen where we don't need text, it doesn't really matter. 
      else if (line == current_calc_line) {
        loopcount++;

// With 50 FPS, this will give an update-rate of 5 hz. (with odd/even lines 10 hz)        
        if (loopcount == 10) {
          loopcount=0;
        } 
        
     
         // with 10 bit ADC and 5 volt ref coltage we have;
         // (with 50 A current sensor)
         // 1024/5 = 205 = 1 volt = 10 A
         // First the ADC is set to take a reading;
         
         if (loopcount == 0) {
             // Setup ADC to be used with current sensor (ADC4), and set the reference voltage. 
              mux_currentSens
               
               // Start the conversion (ADC)
                ADCSRA|=(1<<ADSC);
         }
         
         // In next frame - the analog 
         // reading should have been ready for quite some time
         if (loopcount == 2) {
            
            // The ADC is 10 bit, so we have to read from 2 registers. 
                 ADCtemp=ADCL; 
                 ADCtemp2=ADCH;
            
            // Adding the high and low register;
                ADCreal=ADCtemp+(ADCtemp2<<8);
                
            // Prepare voltage reading for battery-voltage
            // Setup ADC to be used with voltage reading on ADC7, and set the reference voltage. 
            mux_batVoltage
           
            // Start the conversion (ADC)
            ADCSRA|=(1<<ADSC);           
            
            
           // Removes offset.
          
          if (ADCreal <= offset) {
           ADCreal=0;
          }             
          if (ADCreal > offset) {
           ADCreal=ADCreal-offset;
          }  
          
            
         }
         
          // Current calibration. 
         if (loopcount==3) { 
          current_num=ADCreal*current_cal;
           
           // Updates currentr which will be displayed directly on the OSD;
           currentr[0]= (current_num / 100)+3;
           currentr[1]= ((current_num % 100) / 10)+3;
           currentr[2]= 1; // Writes the dot. Should only be done once.           
           currentr[3]= ((current_num % 100) % 10)+3; 
           
           // Updates the total mah consumed. 
           mah = mah+current_num;
           
           // For testing timing.. Almost at the end of line..
           //SPDR=0b11111100;
         }
         
           if (loopcount == 4) {
           // 10.000 mAh is 10 amps in 1 hour. With 5 hz update rate 
           // this will show as 1800000. Divide be 18
           // will give 100000. The last number will be used as decimal. 
           // microcontrollers don't really like decimal-numbers, so we will
           // avoid this
           
           //NTSC have 1.2 times faster framerate.
           
           //PAL
           if (video_system ==0) {
           mahtemp = mah/18;
           }
           
           //NTSC
           else {
           mahtemp = mah/21.6;  
           }
           
           // Prette close at line-end already...
           //SPDR=0b11111100;
           
           // The ADC is 10 bit, so we have to read from 2 registers. (This is used for battery-voltage)
           ADCtemp=ADCL; 
           ADCtemp2=ADCH;
            
            // Adding the high and low register;
                ADCreal=ADCtemp+(ADCtemp2<<8);
         }
         
           if (loopcount == 5) {
          // Updates the 2 first mah numbers;
          
           mahr[0]=(   mahtemp / 10000)+3;           

           // For testing timing.. Almost at the end of line..
           //SPDR=0b11111100;
           
          // Divides with 1.82 - calibration. This matches my voltage-divider (2 resistors).           
          ADCreal2=ADCreal/voltage_divider_cal;
           
         }
         
           if (loopcount == 6) {
           // Updates the 3 last numbers of mAh consumed. 
           mahr[1]=(  (mahtemp % 10000) / 1000)+3;          
           //SPDR=0b11111100;
           
           // Updates the battery-voltage that will be shown. 
           bat_volt=ADCreal2;
           
           voltager[0]= (ADCreal2 / 100)+3;
           voltager[1]= ((ADCreal2 % 100) / 10)+3;
           voltager[2]= 1; // Writes the dot. Should only be done once.           
           voltager[3]= ((ADCreal2 % 100) % 10)+3;     
                      
         }         
         
           if (loopcount == 7) {
           // Updates the 3 last numbers of mAh consumed. 
           mahr[2]=(( (mahtemp % 10000) % 1000) / 100)+3;              
           // Timing seems fine - just at the end of the line
           //SPDR=0b11111100;
         }
         
           if (loopcount == 8) {
           // Updates the 3 last numbers of mAh consumed.              
           mahr[3]=((((mahtemp % 10000) % 1000) % 100) / 10)+3;         
           // Timing seems fine - just at the end of the line
           //SPDR=0b11111100;
         }         
         
                    
           if (loopcount == 9) {
           // Updates the 3 last numbers of mAh consumed.              
           mahr[4]=((((mahtemp % 10000) % 1000) % 100) % 10)+3;
           // Timing seems fine - just at the end of the line
           //SPDR=0b11111100;
         }            
         
            
       }
// ============================================================
// Current sensor END

      // Increase line count..
   line++;

   // Let's make sure SPI is not idling high.
   SPDR=0b00000000;      
          
}





// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================
// ====================================================================================================================================================================================================================

void loop() {

  if (controller ==1) {
   Buttonpin = 6; 
  }
  
  if (controller ==1 | Usebutton == 1) {
  if (digitalRead(Buttonpin)==LOW) {
    
     GPSbuffer[0]=((alt_alarm/1000)+3)<<3;
     GPSbuffer[1]=((alt_alarm%1000/100)+3)<<3;
     GPSbuffer[2]=((alt_alarm%1000%100/10)+3)<<3;
     GPSbuffer[3]=((alt_alarm%1000%100%10)+3)<<3;                  

     GPSbuffer[4]=((los_alarm/1000)+3)<<3;
     GPSbuffer[5]=((los_alarm%1000/100)+3)<<3;
     GPSbuffer[6]=((los_alarm%1000%100/10)+3)<<3;
     GPSbuffer[7]=((los_alarm%1000%100%10)+3)<<3;       

     GPSbuffer[8]=((volt_alarm/1000)+3)<<3;
     GPSbuffer[9]=((volt_alarm%1000/100)+3)<<3;
     GPSbuffer[10]=((volt_alarm%1000%100/10)+3)<<3;
     GPSbuffer[11]=((volt_alarm%1000%100%10)+3)<<3;            

     GPSbuffer[12]=((mah_alarm/1000)+3)<<3;
     GPSbuffer[13]=((mah_alarm%1000/100)+3)<<3;
     GPSbuffer[14]=((mah_alarm%1000%100/10)+3)<<3;
     GPSbuffer[15]=((mah_alarm%1000%100%10)+3)<<3;       
     
    
    
  menuon=1; 
  
  while (menuon==1) {
    

    if (digitalRead(Buttonpin)==LOW) {  
      move_arrow_count=-25;
      while(digitalRead(Buttonpin)==LOW) {
      if (move_arrow_count > -15) {
       break; 
      }
      }
      
      if (menupos == 7 & menu == 1) {
       menuon=0; 

  // Show_mah_km
  EEPROM.write(1,show_mah_km);
  
  // Show decimals
  EEPROM.write(2,show_decimals);
  
  // Altitude offset
  EEPROM.write(3,altitude_offset_on);
  
  // Align text
  EEPROM.write(4,align_text);
  
  // Show plane pos
  EEPROM.write(5,show_plane_pos);  
  
  // Alt alarm
  EEPROM.write(10,(unsigned char) alt_alarm);
  EEPROM.write(11,(unsigned char) (alt_alarm>>8));  
  
  EEPROM.write(12,(unsigned char) los_alarm);
  EEPROM.write(13,(unsigned char) (los_alarm>>8));  

  EEPROM.write(14,(unsigned char) volt_alarm);
  EEPROM.write(15,(unsigned char) (volt_alarm>>8));  

  EEPROM.write(16,(unsigned char) mah_alarm);
  EEPROM.write(17,(unsigned char) (mah_alarm>>8));     

  
      }
      
      if (menupos == 6 & menu == 1) {
       menu=2; 
        
      }
      
      else if (menupos == 1 & menu == 1) {
        if (show_mah_km== 1) {
         show_mah_km =0;
        }
        else {
        show_mah_km =1;
        } 
          
        }
        

      else if (menupos == 2 & menu == 1) {
        if (show_decimals== 1) {
         show_decimals =0;
        }
        else {
        show_decimals =1;
        } 
          
        }



      else if (menupos == 3 & menu == 1) {
        if (altitude_offset_on == 1) {
         altitude_offset_on  =0;
        }
        else {
        altitude_offset_on =1;
        } 
          
        }


      else if (menupos == 4 & menu == 1) {
        align_text++;
        
        if (align_text > 40) {
         align_text = 2; 
        }
          
        }
        

      else if (menupos == 5 & menu == 1) {
        if (show_plane_pos == 1) {
         show_plane_pos  =0;
        }
        else {
        show_plane_pos =1;
        } 
          
        }
        
        
        
        
        
      else if (menupos == 1 & menu == 2) {
            alt_alarm=alt_alarm+50;
            
            if (alt_alarm > 2500) {
              
             alt_alarm=0; 
            }
            
     GPSbuffer[0]=((alt_alarm/1000)+3)<<3;
     GPSbuffer[1]=((alt_alarm%1000/100)+3)<<3;
     GPSbuffer[2]=((alt_alarm%1000%100/10)+3)<<3;
     GPSbuffer[3]=((alt_alarm%1000%100%10)+3)<<3;                    
          
        }        
        
        
      else if (menupos == 2 & menu == 2) {
            los_alarm=los_alarm+50;
            
            if (los_alarm > 2500) {
              
             los_alarm=0; 
            }
     GPSbuffer[4]=((los_alarm/1000)+3)<<3;
     GPSbuffer[5]=((los_alarm%1000/100)+3)<<3;
     GPSbuffer[6]=((los_alarm%1000%100/10)+3)<<3;
     GPSbuffer[7]=((los_alarm%1000%100%10)+3)<<3;                    
          
        }         
        
        
      else if (menupos == 3 & menu == 2) {
            volt_alarm=volt_alarm+1;
            
            if (volt_alarm > 200) {
              
             volt_alarm=50; 
            }
     GPSbuffer[8]=((volt_alarm/1000)+3)<<3;
     GPSbuffer[9]=((volt_alarm%1000/100)+3)<<3;
     GPSbuffer[10]=((volt_alarm%1000%100/10)+3)<<3;
     GPSbuffer[11]=((volt_alarm%1000%100%10)+3)<<3;                     
          
        }    

      else if (menupos == 4 & menu == 2) {
            mah_alarm=mah_alarm+100;
            
            if (mah_alarm > 5000) {
              
             mah_alarm=500; 
            }
     GPSbuffer[12]=((mah_alarm/1000)+3)<<3;
     GPSbuffer[13]=((mah_alarm%1000/100)+3)<<3;
     GPSbuffer[14]=((mah_alarm%1000%100/10)+3)<<3;
     GPSbuffer[15]=((mah_alarm%1000%100%10)+3)<<3;                
          
        }            
        
      else if (menupos == 5 & menu == 2) {
         menu=1; 
        }        
        


        
      
      }
      
  
  
      
      
    }
    
    
    
  }
  
  }
  
  
  

  while (1==1) {
    
       SPDR =0b00000000;
       if (UCSR0A & (1<<RXC0)) {
        GPSbuffer[bufnr] = UDR0;

        bufnr++;
        
     // This code is not very efficient, but as it will only be executed 1-10 
     // times a second (1-10 hz update rate from GPS) it's not as critical as the video-timing.
     
     // The major problem by doing it this way is, that the text-string has to be
     // "analyzed" before the next character is received.  
    
    // If the last character is 13 = carriage return, an entire line has been received.
        if (GPSbuffer[bufnr-1] == 13){
                 
      // Check if it's the GPRMC-string that has been received;
      // If it's the GPRMC-string, the characher at index 4 = R
      
      
      // ====================================================================================
      // Second GPS String      
      // ====================================================================================
      
      if (GPSbuffer[4]=='R') {
        
        // Resets the speed to avoid "hanging numbers". 
        speedkn[0]=14;
        speedkn[1]=14;
        speedkn[2]=14;
        speedkn[3]=14;
        speedkn[4]=14;        

        // Goes through every character in the line. As the GPS-data is ","-seperated
        // we can look for the "," and find the data needed. 
        for (int i = 0; i<bufnr; i++) {
          if (GPSbuffer[i]==',') {
            n=0;
            count++;
          }
        
          else {
              switch (count) {
                
              case 0: break;
              
              case 1: 
              time[n]=GPSbuffer[i]-45;
              break; 
              
              case 2: break;
              
              case 3: 
              latitude[n]=GPSbuffer[i];
              break; 
              
              case 4:
              latitude_dir=GPSbuffer[i];
              break;
              
              case 5:
              longitude[n]=GPSbuffer[i];
              break; 
              
              case 6: 
              longitude_dir=GPSbuffer[i];
              break;
              
              case 7:
              speedkn[n]=GPSbuffer[i]-45;
              break; 
              
              case 8:
              head[n]=GPSbuffer[i];
              break;
              
              default: break;
              
            }
            // Don't need more data efter the 9. "," - so we will just break.
            if (count == 9) {
             break; 
            }
            
            n++;
          }
      }
      
      speedkn2[0]=speedkn[0];
      speedkn2[1]=speedkn[1];
      speedkn2[2]=speedkn[2];
      speedkn2[3]=speedkn[3];
      speedkn2[4]=speedkn[4];
              
  
      // So, when this last string has been received we got "plenty of time" to do some math....
      // okay, at 9600 baud rate the 2 strings takes around 80 % of the bandwidth (5 hz update rate),
      // but at least it gives us around 0,04 seconds. 
      
      // If you need the micro-controller for further calculations you might want to
      // improve this code a bit. 
      


      //===================================================      
      // GPS coordinates
      //===================================================   
      // Coordinates from MKT is like; 5559.5395
      // 55 as degrees and 59 as minutes (or something that ends with 60 ;)) and 5395 as "normal number/decimal system"

      
      lat1=
      (latitude[8]-48)+
      (latitude[7]-48)*10+
      (latitude[6]-48)*100+
      (latitude[5]-48)*1000;
      
      // Degrees. 
      lat2=
      (latitude[3]-48)+
      (latitude[2]-48)*10+
      (latitude[1]-48)*60+
      (latitude[0]-48)*600;
      
      lats=lat1+(lat2*10000);
      
      lon1=
      (longitude[9]-48)+
      (longitude[8]-48)*10+
      (longitude[7]-48)*100+
      (longitude[6]-48)*1000;
      
      lon2=
      (longitude[4]-48)+
      (longitude[3]-48)*10+
      (longitude[2]-48)*60+
      (longitude[1]-48)*600+
      (longitude[0]-48)*6000;
      
      lons=lon1+(lon2*10000);
      
      //===================================================      
      // End of GPS coordinates
      //===================================================
    
    
    
      //===================================================      
      // Calculate LOS and heading
      //===================================================  
    if (homepos ==1) {
      losy = ((lathome - lats)*185)/1000;
      losx = ((lonhome - lons)*185*longitude_factor)/1000;
      los=sqrt((losy*losy)+(losx*losx));
      
      // Resets LOS to avoid "hanging numbers"
      losr[0]=14;
      losr[1]=14;
      losr[2]=14;
      losr[3]=14;      
      
      if (units== 0) {
       los = los * 3.28; 
      }
      
      losr[0]=(  los/1000)+3;
      losr[1]=(( los%1000)/100)+3;      
      losr[2]=(((los%1000)%100)/10)+3; 
      losr[3]=(((los%1000)%100)%10)+3;
      
      // Calculate heading home.
      
      // This piece of code could probably be more efficient, but for now it gets the job done.  
      if (latitude_dir == 'S') {
        losy=losy*(-1);
      }
      
      if (longitude_dir == 'W') {
        losx=losx*(-1);
      }      

          if (losy > 0) {
              if (losx > 0) {
                // Arrow right up
                homehead = 90-asin(losy/(double(los)))*57;
              }
              if (losx <= 0) {
                // Arrow left up
                homehead = 270+asin(losy/(double(los)))*57;
              }
          }
          
          if (losy <= 0) {
              if (losx > 0) {
                // Arrow right down
                homehead = 90+acos(losx/(double(los)))*57;
              }
              if (losx <= 0) {
                // Arrow left down
                homehead = 270-acos(abs(losx)/(double(los)))*57;
              }
          }       
                    
              if (show_plane_pos == 1) {
               homehead_r[0] = ((homehead/100)+3)<<5;
               homehead_r[1] = ((homehead%100/10)+3)<<5;
               homehead_r[2] = ((homehead%100%10)+3)<<5;               
                
                
              }
      
    
      
      
      
      //Last part.. Need to calculate which way 
      // the arrow needs to point. 
      
      // First we need to convert the heading to an integer
       headi=0;
      for (i=0;i<3;i++) {
         if (head[i]<48) {
           break;
         }
         headi=headi*10+(head[i]-48);

      }
      arrow = homehead - headi; 
      if (arrow < 0) {
      arrow = arrow + 360;
      }     
      
      arrowr[0]=(  arrow/100)+3;
      arrowr[1]=(( arrow%100)/10)+3;      
      arrowr[2]=(( arrow%100)%10)+3; 
    }
  
  
      //===================================================      
      // END los calculation
      //=================================================== 



      //===================================================      
      // Calculate speed - to km/h
      //===================================================      

    if (speedkn2[0] < 14) {
      
          speedkm=0;
      for (i=0;i<3;i++) {
        if (speedkn2[i]<3) {
           break;
        }
      speedkm=speedkm*10+(speedkn2[i]-3);
      }
      speedkm = speedkm*10+(speedkn2[i+1]-3);
    
    
    
    if (units==0) {
      speedkm=(speedkm*11.51)/10; 
    }
    else {
      speedkm=(speedkm*18.52)/10;
    }
      
      
      speedkmw[0]=(  speedkm/1000)+3;
      speedkmw[1]=(( speedkm%1000)/100)+3;      
      speedkmw[2]=(((speedkm%1000)%100)/10)+3; 
      speedkmw[3]=(((speedkm%1000)%100)%10)+3; 
      
    }
   speedkm2=speedkm;
      //===================================================      
      // End speed calculation
      //===================================================    
      
      
      //===================================================      
      // Flight summary
      //===================================================  
      if (speedkm > max_speed) {
        max_speed = speedkm;
      
      max_speedr[0]=(  max_speed/1000)+3;
      max_speedr[1]=(( max_speed%1000)/100)+3;      
      max_speedr[2]=(((max_speed%1000)%100)/10)+3; 
      max_speedr[3]=(((max_speed%1000)%100)%10)+3;  
        
      }
      
      if (los > max_los) {
        max_los = los;
        
      max_losr[0]=(  max_los/1000)+3;
      max_losr[1]=(( max_los%1000)/100)+3;      
      max_losr[2]=(((max_los%1000)%100)/10)+3; 
      max_losr[3]=(((max_los%1000)%100)%10)+3;          
        
      }      
      

       if (altitude[0] < 14) {

         altitude_num=0;
          for (i=0;i<6;i++) {
            if (altitude[i] < 3) {
               break;
            }
          altitude_num=altitude_num*10+(altitude[i]-3);
          }
          
          altitude_num=altitude_num*10+(altitude[i+1]-3);
    
      if (units==0) {
       altitude_num = altitude_num * 3.28; 
      }
    
    
          if (altitude_offset_on == 1) {
            altitude_num=altitude_num-altitude_offset;
            if (altitude_num<0) {
              altitude_num=abs(altitude_num);
              altitude_negative=1; 
            }
            else{
            altitude_negative=0;
            }
            
          }
    
          altitude_num2=altitude_num;
          altituder[0]=(  (altitude_num/10000)+3);  
          altituder[1]=(  (altitude_num%10000)/1000)+3;
          altituder[2]=(( (altitude_num%10000)%1000)/100)+3;      
          altituder[3]=((((altitude_num%10000)%1000)%100)/10)+3; 
          altituder[4]=((((altitude_num%10000)%1000)%100)%10)+3;
             
          
          if (altitude_num > max_alt) {
          max_alt = altitude_num; 
    
          max_altr[0]=altituder[0];
          max_altr[1]=altituder[1];
          max_altr[2]=altituder[2];
          max_altr[3]=altituder[3];
          max_altr[4]=altituder[4];
         
          }
      
      }

      
      // Add time
      if (time[5] !=last_time) {
      last_time=time[5];
      flight_time++;
      
      flight_timer[0]=(( flight_time/600))+3;     
      flight_timer[1]=(((flight_time%600)/60))+3;      
      flight_timer[2]=((flight_time%600)%60)/10+3; 
      flight_timer[3]=((flight_time%600)%60)%10+3; 
      
      kmh_total=kmh_total+speedkm;

      total_distancer[0]=(   (kmh_total/36)/10000)+3;      
      total_distancer[1]=(  ((kmh_total/36)%10000)/1000)+3;
      total_distancer[2]=(( ((kmh_total/36)%10000)%1000)/100)+3;      
      total_distancer[3]=(((((kmh_total/36)%10000)%1000)%100)/10)+3; 
      total_distancer[4]=(((((kmh_total/36)%10000)%1000)%100)%10)+3;     
     
      // Avg speed...
      avg_speed = kmh_total / flight_time;
      
      avg_speedr[0]=(  avg_speed/1000)+3;
      avg_speedr[1]=(( avg_speed%1000)/100)+3;      
      avg_speedr[2]=(((avg_speed%1000)%100)/10)+3; 
      avg_speedr[3]=(((avg_speed%1000)%100)%10)+3;           
      
      }

      


      //===================================================      
      // Flight summary END
      //===================================================        
          
      //===================================================      
      // Set homeposition
      //===================================================    
      
    // This is used to set homeposition. 
     if (homepos == 0) {
       // If we have GPS-fix;
       if (GPSfix > '0') {
         homeposcount++;
         if (homeposcount > set_home_delay) {
           lathome = lats;
           lonhome = lons;
           homepos = 1;
           
            max_los =0;
            max_speed=0;
            kmh_total=0;
            max_alt=0;
            flight_time=0;
            altitude_offset = altitude_num;
            
            lat_deg= (latitude[1]-48)+ (latitude[0]-48)*10;
            longitude_factor = cos((lat_deg*2*3.14)/360);

         }
       }
     }
     
     
      //===================================================      
      // End set homeposition
      //===================================================
      
      
      if (speedkm < summary_speed*10 && los < summary_los && current_num < summary_current*10 && flight_time > summary_time && altitude_num < summary_altitude*10) {
       landed = 1; 
      }
      else {
       landed = 0; 
      }

      long_buf=current_num;
      if (show_mah_km ==1) {
        
        if (speedkm2 > 10) {
        mahkm=((long_buf*1000)/(speedkm2));
        }
        
        if (mahkm > 9999) {
         mahkm = 9999; 
        }
        
        mahkmr[0]=(  mahkm/1000)+3;
        mahkmr[1]=(( mahkm%1000)/100)+3;      
        mahkmr[2]=(((mahkm%1000)%100)/10)+3; 
        mahkmr[3]=(((mahkm%1000)%100)%10)+3;
       }







      }

    
    
    
    
    
      // ====================================================================================
      // Second GPS String END     
      // ====================================================================================    



    // Check if the line is the GGA nmea GPS-line:
    
          if (GPSbuffer[6]=='A' && GPSbuffer[5] =='G') {
            
            // Again, reset altitude to avoid "hanging characters". 
            // Can maybe be done smarter. 

                 altitude[0]=14;
                 altitude[1]=14;         
                 altitude[2]=14;         
                 altitude[3]=14;
                 altitude[4]=14;
                 altitude[5]=14;
                 
                 satellites[0]=14;
                 satellites[1]=14;                 
                 
        for (int i = 0; i<bufnr; i++) {
          if (GPSbuffer[i]==',') {
            n=0;
            count++;
          }
        
          else {
              switch (count) {
              
              case 6:
              GPSfix = GPSbuffer[i];  
              break;  

              case 7:
              satellites[n] = GPSbuffer[i]-45;
              break;
              
              case 9:
              altitude[n]=GPSbuffer[i]-45;
              break; 

              default: break;
              
            }
            
            if (count == 10) {
             break; 
            }
            
            n++;
          
            
          }
      }      
      
           altitude2[0]=altitude[0];
           altitude2[1]=altitude[1];         
           altitude2[2]=altitude[2];         
           altitude2[3]=altitude[3];
           altitude2[4]=altitude[4];
           altitude2[5]=altitude[5];  
           
           satellitesr[0]=satellites[0];
           satellitesr[1]=satellites[1];            

    }
    

    
    // No matter what has been received, count and bufnr is reset
    // to be ready to receive the next GPS string.
    count=0;
    bufnr=0;

    }        
             if (bufnr > 98) {
               bufnr=0;
             }
       
        
       }
        
  }
}




